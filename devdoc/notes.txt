==================================================
Dumb things you always forget for a release build
==================================================

Adding support for a new release of the Kubernetes client
---------------------------------------------------------

So a couple of files need to be tweaked to ensure the build runs properly
and some minor adjustments are made for the few aberrations in how some
resources are named.

1. Add new entries to build_helper.json for the release: this is the file that
   helps the builder sort out what version of a resource to prefer when reading
   the same named resource from multiple groups in the same version (there are
   a short list of usual culprits here like Event, Subject, Token, etc). You can
   start by copying the previous release's entries, but may need to adjust
   due to testing results. The builder will crash if you don't make an entry
   for the new release (this is deliberate to ensure you fix build_helper.json)
   and not just blindly provide a default that won't cause an error but will
   be hard to track down when you lose versions of resources you thought you
   had. It's sensible to pare this down to the minimum required, but it's
   harmless to have too many (but unneeded) entries.
2. Put a new entry into the _deprecation_helper dict in generate.py, usually
   only involving Event. That resource appears to have been moved from core to
   events, but the core variation is being kept around for a while it seems.
   This screws up certain deserialization operations, and the lack of it mani-
   fests itself in errors having to do with Event in the generated_methods
   and integration tests.


Make a method/class map snapshot
--------------------------------
cd devtools
python methodmap.py > release_maps/{snapshot_file}  # once the model has settled down
python mcompare.py {oldmap} {newmap}   # the one from above

Where to change version numbers for a new release
-------------------------------------------------
hikaru/__init__.py: __version__
hikaru/setup.py: __version__
hikaru/README.rst

Changes to setup.py
-------------------
Fix the version number as above
Add the new model packages to the 'packages' key
Delete any newly obsolescent packages

Removing deprecated support for a K8s release
------------------------------------------------
Remove all tests that have the release number in them
Remove all test run scripts that have the release number in them
Update the whole test run script to no longer run those other scripts/tests
Remove all build tools that have the release number in them
Adjust the build tools to create a new default and deprecated release
Re-build the release that is now deprecated
Build the new release to be the default
Adjust setup.py as above
Remove the model modules from hikaru.model


Other build tasks
-----------------
- in docs/ create a new reference document for the release (rel-1-XX-v1.rst), and
  be sure to edit the content to contain all the correct release numbers
- update docs/index.rst to include the new ref docs and remove any deprecated
  ref docs
- build the docs to be sure they are correct (make clean/html); check to be sure
  that the release number is picked up correctly
- Edit setup.py to include the new model packages and remove any deprecated ones (if any)
- Update the table in docs/model-releases-and-versions.rst

Building
--------
building the package: python setup.py bdist_wheel

Build testing process
---------------------
For each supported version of Python:
    create a virtual env 'ht' (use virtualenv for 3.8, venv for the rest)
    activate ht
    pip install the installation package
    pip install the maintainers requirements
    cd into hikaru/tests; DO NOT set PYTHONPATH so you will use the installed package!
    execute ./runall.bsh, note results
    deactivate the virtual env
    rm -rf ht

Publishing to PyPI
------------------
publishing to test PyPI: twine upload --repository-url https://test.pypi.org/legacy/ dist/*
publishing to official PyPI: twine upload dist/*

CLA assistant at:  https://cla-assistant.io/
Assistant repo: https://github.com/cla-assistant/cla-assistant

SO question about finding the types inside a Union
https://stackoverflow.com/questions/45957615/check-a-variable-against-union-type-at-runtime-in-python-3-6

The JSON Swagger file that describes all objects in the API is here:
https://github.com/kubernetes-client/python/blob/master/kubernetes/swagger.json.unprocessed

# example
from inspect import signature

# give me all the parameters for the dunder init for Outer
[p for p in signature(Outer.__init__).parameters.values()]
# p.kind tells whether positional, keyword, etc

# with this class:
class Outer(object):
    f2: float
    s1: str
    l2: Optional[List[Inner]] = dataclasses.field(default_factory=list)

# this expression finds l2's optional type, which is 'list':
get_origin(get_args(dataclasses.fields(Outer)[2].type)[0])
# and this one finds l2's list element type
get_args(get_args(dataclasses.fields(Outer)[2].type)[0])[0]

# if you hav a single field object for l2:
f = dataclasses.fields(Outer)[2]
# then it's just a matter of drilling into the .type attr
# once you peel away the Union that is generated by Optional:
inner_type = get_args(dataclasses.fields(Outer)[2].type)[0]
# this gets the container type (list):
get_origin(inner_type)
# and this gets the type in the list
get_args(inner_type)[0]


x = P
1234
