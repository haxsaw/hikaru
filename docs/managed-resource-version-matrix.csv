,resource_version is None (default value),resource_version is a resource version number (str or int)
manage resource version is False (default value),"May be K8s system dependent. On k3s, it results in the delivery of an ADDED event for each operating resource of the type specified for the Watcher, and then subsequent events of the resource type as they occur. If the underlying watch is restarted, then it is as if the stream() was started the first time: ADDED events for any existing resources of the Watcher’s type, and then any new events that occur while the Watcher is streaming. This means if you set a timeout for the Watcher and the underlying watch does indeed timeout, you may miss some events before the Watcher restarts the watch and the stream starts delivering events again. In general, this isn’t a very useful combination of options except when first trying out Watchers.","Indicates that you only want to receive events for this resource that come after the specified resource_version number. If this number is too low (there are no events held by the K8s system that far back), you will get an ApiException raised with a 410 status code and a reason string that names the oldest resource_version that is held by K8s at the present time. The exception class is found in kubernetes.client. This is a useful combination of options if the consumer of Watcher events will be making a record of the resourceVersions delivered so that in the case of a restart you can leap to the last observed resourceVersion and continue processing."
manage resource version is True,"When Watcher.stream() starts execution, it begins by finding the lowest resourceVersion available for that resource, and then uses that value for resource_version in the underlying watch. This usually results in a series of initial events that may have already occurred in the past but should bring you up to date as to the current state of the K8s system. After this initial catch-up, the Watcher will then continue to process events as they arrive, but will also capture each newer resourceVersion values that are higher than the last kept version. If the underlying watch terminates for any reason (an exception or timeout), then the Watcher will use this highest observed resourceVersion as the new value for resource_version when it restarts the underlying watch, or even if the stream() call itself is re-started. Additionally, if any gaps wind up appearing in the event stream (as can happen), the Watcher will in this case move to the proper resourceVersion and continue processing events. This combination is good if you can survive receiving events that may have occurred in the past, but otherwise don’t want to bother with tracking the highest-valued resourceVersion.","In this case, as there is an initial resource_version specified when the Watcher was made, there is no attempt to look for the oldest available resourceVersion and ‘catch up’; the supplied resource_version will be used on the underlying watch and events will be processed from there. However, if it turns out that that the supplied version is too old and results in a 410 error, the Watcher will catch that and determine the lowest available version, and then continue to process from there. It will also record the highest observed resourceVersion as it processes events and will re-start the watch at this value if the underlying watch needs to be restarted or if the Watcher itself gets restarted with a new call to stream(). This combination is good when you don’t want to ever receive events that you’ve already received and can persist the highest-valued resourceVersion that has come out of the Watcher."
