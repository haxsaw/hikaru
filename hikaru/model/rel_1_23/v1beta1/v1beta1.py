#
# Copyright (c) 2021 Incisive Technology Ltd
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
"""
DO NOT EDIT THIS FILE!

This module is automatically generated using the Hikaru build program that turns
a Kubernetes swagger spec into the code for the hikaru.model package.
"""


from hikaru.meta import HikaruBase, HikaruDocumentBase, KubernetesException, WatcherDescriptor
from hikaru.generate import get_clean_dict
from hikaru.utils import Response
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field, InitVar
from kubernetes.client import CoreV1Api
from ..unversioned import *

from kubernetes.client import ApiClient
from kubernetes.client import BatchV1beta1Api
from kubernetes.client import DiscoveryV1beta1Api
from kubernetes.client import EventsV1beta1Api
from kubernetes.client import FlowcontrolApiserverV1beta1Api
from kubernetes.client import NodeV1beta1Api
from kubernetes.client import PolicyV1beta1Api
from kubernetes.client import StorageV1beta1Api
from ..v1 import Status
from ..v1 import ObjectMeta
from ..v1 import DeleteOptions
from ..v1 import ListMeta
from ..v1 import ObjectReference
from ..v1 import JobSpec
from ..v1 import EventSource
from ..v1 import Toleration
from ..v1 import LabelSelector
from ..v1 import Condition
from ..v1 import SELinuxOptions


@dataclass
class CronJob(HikaruDocumentBase):
    r"""
    CronJob represents the configuration of a single cron job.

    Full name: CronJob

    Attributes:
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata: Standard object's metadata. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    spec: Specification of the desired behavior of a cron job, including the schedule.
        More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    status: Current status of a cron job. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    """

    _version = "v1beta1"
    apiVersion: Optional[str] = "batch/v1beta1"
    kind: Optional[str] = "CronJob"
    metadata: Optional["ObjectMeta"] = None
    spec: Optional["CronJobSpec"] = None
    status: Optional["CronJobStatus"] = None
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def deleteCollectionNamespacedCronJob(
        namespace: str,
        continue_: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_selector: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["CronJob"]:
        r"""
        delete collection of CronJob

        operationID: deleteCollectionNamespacedCronJob
        path: /apis/batch/v1beta1/namespaces/{namespace}/cronjobs

        :param namespace: namespace for the resource
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Status    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = BatchV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "delete_collection_namespaced_cron_job_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_collection_namespaced_cron_job_with_http_info "
                "on BatchV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["namespace"] = namespace
        all_args["_continue"] = continue_
        all_args["dry_run"] = dry_run
        all_args["field_selector"] = field_selector
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["CronJob"] = Response["CronJob"](result, codes_returning_objects)
        return resp

    def createNamespacedCronJob(
        self,
        namespace: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["CronJob"]:
        r"""
        create a CronJob

        operationID: createNamespacedCronJob
        path: /apis/batch/v1beta1/namespaces/{namespace}/cronjobs

        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   CronJob    OK
          201   CronJob    Created
          202   CronJob    Accepted
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = BatchV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "create_namespaced_cron_job_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "create_namespaced_cron_job_with_http_info "
                "on BatchV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201, 202)
        resp: Response["CronJob"] = Response["CronJob"](result, codes_returning_objects)
        return resp

    def create(
        self,
        namespace: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
    ) -> "CronJob":
        r"""
            create a CronJob

            operationID: createNamespacedCronJob
            path: /apis/batch/v1beta1/namespaces/{namespace}/cronjobs

            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint.
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to create() or in a "
                "CronJob's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace
        res = self.createNamespacedCronJob(
            namespace=effective_namespace,
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    @staticmethod
    def deleteNamespacedCronJob(
        name: str,
        namespace: str,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["CronJob"]:
        r"""
        delete a CronJob

        operationID: deleteNamespacedCronJob
        path: /apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Status    OK
          202   Status    Accepted
          401   None    Unauthorized
        """
        client_to_use = client
        inst = BatchV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "delete_namespaced_cron_job_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_namespaced_cron_job_with_http_info "
                "on BatchV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 202)
        resp: Response["CronJob"] = Response["CronJob"](result, codes_returning_objects)
        return resp

    def delete(
        self,
        name: Optional[str] = None,
        namespace: Optional[str] = None,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        client: ApiClient = None,
    ) -> "CronJob":
        r"""
            delete a CronJob

            operationID: deleteNamespacedCronJob
            path: /apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param grace_period_seconds: The duration in seconds before the object should
                be deleted. Value must be non-negative integer. The value zero
                indicates delete immediately. If this value is nil, the default
                grace period for the specified type will be used. Defaults to a per
                object value if not specified. zero means delete immediately.
            :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
                field will be deprecated in 1.7. Should the dependent objects be
                orphaned. If true/false, the "orphan" finalizer will be added
                to/removed from the object's finalizers list. Either this field or
                PropagationPolicy may be set, but not both.
            :param propagation_policy: Whether and how garbage collection will be
                performed. Either this field or OrphanDependents may be set, but not
                both. The default policy is decided by the existing finalizer set in
                the metadata.finalizers and the resource-specific default policy.
                Acceptable values are: 'Orphan' - orphan the dependents;
                'Background' - allow the garbage collector to delete the dependents
                in the background; 'Foreground' - a cascading policy that deletes
                all dependents in the foreground.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to delete() or in a "
                "CronJob's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to delete() or in a "
                "CronJob's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.deleteNamespacedCronJob(
            name=effective_name,
            namespace=effective_namespace,
            dry_run=dry_run,
            grace_period_seconds=grace_period_seconds,
            orphan_dependents=orphan_dependents,
            propagation_policy=propagation_policy,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    @staticmethod
    def readNamespacedCronJob(
        name: str,
        namespace: str,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["CronJob"]:
        r"""
        read the specified CronJob

        operationID: readNamespacedCronJob
        path: /apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   CronJob    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = BatchV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "read_namespaced_cron_job_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "read_namespaced_cron_job_with_http_info "
                "on BatchV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["CronJob"] = Response["CronJob"](result, codes_returning_objects)
        return resp

    def read(
        self,
        name: Optional[str] = None,
        namespace: Optional[str] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
    ) -> "CronJob":
        r"""
            read the specified CronJob

            operationID: readNamespacedCronJob
            path: /apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param pretty: If 'true', then the output is pretty printed.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to read() or in a "
                "CronJob's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to read() or in a "
                "CronJob's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.readNamespacedCronJob(
            name=effective_name,
            namespace=effective_namespace,
            pretty=pretty,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    def patchNamespacedCronJob(
        self,
        name: str,
        namespace: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["CronJob"]:
        r"""
        partially update the specified CronJob

        operationID: patchNamespacedCronJob
        path: /apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint. This field is
            required for apply requests (application/apply-patch) but optional
            for non-apply patch types (JsonPatch, MergePatch,
            StrategicMergePatch).
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param force: Force is going to "force" Apply requests. It means user will
            re-acquire conflicting fields owned by other people. Force flag must
            be unset for non-apply patch requests.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   CronJob    OK
          201   CronJob    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = BatchV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "patch_namespaced_cron_job_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "patch_namespaced_cron_job_with_http_info "
                "on BatchV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        all_args["force"] = force
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["CronJob"] = Response["CronJob"](result, codes_returning_objects)
        return resp

    def update(
        self,
        namespace: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
    ) -> "CronJob":
        r"""
            partially update the specified CronJob

            operationID: patchNamespacedCronJob
            path: /apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}

            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint. This field is
                required for apply requests (application/apply-patch) but optional
                for non-apply patch types (JsonPatch, MergePatch,
                StrategicMergePatch).
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param force: Force is going to "force" Apply requests. It means user will
                re-acquire conflicting fields owned by other people. Force flag must
                be unset for non-apply patch requests.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to update() or in a "
                "CronJob's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace
        res = self.patchNamespacedCronJob(
            name=self.metadata.name,
            namespace=effective_namespace,
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            force=force,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    def __enter__(self):
        return self

    def __exit__(self, ex_type, ex_value, ex_traceback):
        passed = ex_type is None and ex_value is None and ex_traceback is None
        has_rollback = hasattr(self, "__rollback")
        if passed:
            try:
                self.update()
            except Exception:
                if has_rollback:
                    self.merge(getattr(self, "__rollback"), overwrite=True)
                    delattr(self, "__rollback")
                raise
        if has_rollback:
            if not passed:
                self.merge(getattr(self, "__rollback"), overwrite=True)
            delattr(self, "__rollback")
        return False

    def replaceNamespacedCronJob(
        self,
        name: str,
        namespace: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["CronJob"]:
        r"""
        replace the specified CronJob

        operationID: replaceNamespacedCronJob
        path: /apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   CronJob    OK
          201   CronJob    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = BatchV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "replace_namespaced_cron_job_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "replace_namespaced_cron_job_with_http_info "
                "on BatchV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["CronJob"] = Response["CronJob"](result, codes_returning_objects)
        return resp

    def replaceNamespacedCronJobStatus(
        self,
        name: str,
        namespace: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["CronJob"]:
        r"""
        replace status of the specified CronJob

        operationID: replaceNamespacedCronJobStatus
        path: /apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   CronJob    OK
          201   CronJob    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = BatchV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "replace_namespaced_cron_job_status_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "replace_namespaced_cron_job_status_with_http_info "
                "on BatchV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["CronJob"] = Response["CronJob"](result, codes_returning_objects)
        return resp


@dataclass
class CronJobList(HikaruDocumentBase):
    r"""
    CronJobList is a collection of cron jobs.

    Full name: CronJobList

    Attributes:
    items: items is the list of CronJobs.
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata: Standard list metadata. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    """

    _version = "v1beta1"
    items: List["CronJob"]
    apiVersion: Optional[str] = "batch/v1beta1"
    kind: Optional[str] = "CronJobList"
    metadata: Optional["ListMeta"] = None
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def listCronJobForAllNamespaces(
        allow_watch_bookmarks: Optional[bool] = None,
        continue_: Optional[str] = None,
        field_selector: Optional[str] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        pretty: Optional[str] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        watch: Optional[bool] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["CronJobList"]:
        r"""
        list or watch objects of kind CronJob

        operationID: listCronJobForAllNamespaces
        path: /apis/batch/v1beta1/cronjobs

        :param allow_watch_bookmarks: allowWatchBookmarks requests watch events with
            type "BOOKMARK". Servers that do not implement bookmarks may ignore
            this flag and bookmarks are sent at the server's discretion. Clients
            should not assume bookmarks are returned at any specific interval,
            nor may they assume the server will send any BOOKMARK event during a
            session. If this is not a watch, this field is ignored.
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param pretty: If 'true', then the output is pretty printed.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param watch: Watch for changes to the described resources and return them as a
            stream of add, update, and remove notifications. Specify
            resourceVersion.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   CronJobList    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = BatchV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "list_cron_job_for_all_namespaces_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "list_cron_job_for_all_namespaces_with_http_info "
                "on BatchV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["allow_watch_bookmarks"] = allow_watch_bookmarks
        all_args["_continue"] = continue_
        all_args["field_selector"] = field_selector
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["pretty"] = pretty
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["watch"] = watch
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["CronJobList"] = Response["CronJobList"](
            result, codes_returning_objects
        )
        return resp

    _watcher = WatcherDescriptor(
        "kubernetes.client.api",
        ".batch_v1beta1_api",
        "BatchV1beta1Api",
        "list_cron_job_for_all_namespaces",
    )

    @staticmethod
    def listNamespacedCronJob(
        namespace: str,
        allow_watch_bookmarks: Optional[bool] = None,
        continue_: Optional[str] = None,
        field_selector: Optional[str] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        watch: Optional[bool] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["CronJobList"]:
        r"""
        list or watch objects of kind CronJob

        operationID: listNamespacedCronJob
        path: /apis/batch/v1beta1/namespaces/{namespace}/cronjobs

        :param namespace: namespace for the resource
        :param allow_watch_bookmarks: allowWatchBookmarks requests watch events with
            type "BOOKMARK". Servers that do not implement bookmarks may ignore
            this flag and bookmarks are sent at the server's discretion. Clients
            should not assume bookmarks are returned at any specific interval,
            nor may they assume the server will send any BOOKMARK event during a
            session. If this is not a watch, this field is ignored.
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param watch: Watch for changes to the described resources and return them as a
            stream of add, update, and remove notifications. Specify
            resourceVersion.
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   CronJobList    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = BatchV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "list_namespaced_cron_job_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "list_namespaced_cron_job_with_http_info "
                "on BatchV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["namespace"] = namespace
        all_args["allow_watch_bookmarks"] = allow_watch_bookmarks
        all_args["_continue"] = continue_
        all_args["field_selector"] = field_selector
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["watch"] = watch
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["CronJobList"] = Response["CronJobList"](
            result, codes_returning_objects
        )
        return resp

    _namespaced_watcher = WatcherDescriptor(
        "kubernetes.client.api",
        ".batch_v1beta1_api",
        "BatchV1beta1Api",
        "list_namespaced_cron_job",
    )


@dataclass
class CronJobSpec(HikaruBase):
    r"""
    CronJobSpec describes how the job execution will look like and when it will actually
    run.

    Full name: CronJobSpec

    Attributes:
    jobTemplate: Specifies the job that will be created when executing a CronJob.
    schedule: The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
    concurrencyPolicy: Specifies how to treat concurrent executions of a Job. Valid values
        are: - "Allow" (default): allows CronJobs to run concurrently; - "Forbid": forbids
        concurrent runs, skipping next run if previous run hasn't finished yet; -
        "Replace": cancels currently running job and replaces it with a new one
    failedJobsHistoryLimit: The number of failed finished jobs to retain. This is a
        pointer to distinguish between explicit zero and not specified. Defaults to 1.
    startingDeadlineSeconds: Optional deadline in seconds for starting the job if it
        misses scheduled time for any reason. Missed jobs executions will be counted as
        failed ones.
    successfulJobsHistoryLimit: The number of successful finished jobs to retain. This is
        a pointer to distinguish between explicit zero and not specified. Defaults to 3.
    suspend: This flag tells the controller to suspend subsequent executions, it does not
        apply to already started executions. Defaults to false.
    """

    jobTemplate: "JobTemplateSpec"
    schedule: str
    concurrencyPolicy: Optional[str] = None
    failedJobsHistoryLimit: Optional[int] = None
    startingDeadlineSeconds: Optional[int] = None
    successfulJobsHistoryLimit: Optional[int] = None
    suspend: Optional[bool] = None


@dataclass
class CronJobStatus(HikaruBase):
    r"""
    CronJobStatus represents the current state of a cron job.

    Full name: CronJobStatus

    Attributes:
    lastScheduleTime: Information when was the last time the job was successfully
        scheduled.
    lastSuccessfulTime: Information when was the last time the job successfully completed.
    active: A list of pointers to currently running jobs.
    """

    lastScheduleTime: Optional[str] = None
    lastSuccessfulTime: Optional[str] = None
    active: Optional[List["ObjectReference"]] = field(default_factory=list)


@dataclass
class JobTemplateSpec(HikaruBase):
    r"""
    JobTemplateSpec describes the data a Job should have when created from a template

    Full name: JobTemplateSpec

    Attributes:
    metadata: Standard object's metadata of the jobs created from this template. More
        info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    spec: Specification of the desired behavior of the job. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    """

    metadata: Optional["ObjectMeta"] = None
    spec: Optional["JobSpec"] = None


@dataclass
class Endpoint(HikaruBase):
    r"""
    Endpoint represents a single logical "backend" implementing a service.

    Full name: Endpoint

    Attributes:
    addresses: addresses of this endpoint. The contents of this field are interpreted
        according to the corresponding EndpointSlice addressType field. Consumers must
        handle different types of addresses in the context of their own capabilities. This
        must contain at least one address but no more than 100.
    conditions: conditions contains information about the current status of the endpoint.
    hints: hints contains information associated with how an endpoint should be consumed.
    hostname: hostname of this endpoint. This field may be used by consumers of endpoints
        to distinguish endpoints from each other (e.g. in DNS names). Multiple endpoints
        which use the same hostname should be considered fungible (e.g. multiple A values
        in DNS). Must be lowercase and pass DNS Label (RFC 1123) validation.
    nodeName: nodeName represents the name of the Node hosting this endpoint. This can be
        used to determine endpoints local to a Node. This field can be enabled with the
        EndpointSliceNodeName feature gate.
    targetRef: targetRef is a reference to a Kubernetes object that represents this
        endpoint.
    topology: topology contains arbitrary topology information associated with the
        endpoint. These key/value pairs must conform with the label format.
        https://kubernetes.io/docs/concepts/overview/working-with-objects/labels Topology
        may include a maximum of 16 key/value pairs. This includes, but is not limited to
        the following well known keys: * kubernetes.io/hostname: the value indicates the
        hostname of the node where the endpoint is located. This should match the
        corresponding node label. * topology.kubernetes.io/zone: the value indicates the
        zone where the endpoint is located. This should match the corresponding node
        label. * topology.kubernetes.io/region: the value indicates the region where the
        endpoint is located. This should match the corresponding node label. This field is
        deprecated and will be removed in future api versions.
    """

    addresses: List[str]
    conditions: Optional["EndpointConditions"] = None
    hints: Optional["EndpointHints"] = None
    hostname: Optional[str] = None
    nodeName: Optional[str] = None
    targetRef: Optional["ObjectReference"] = None
    topology: Optional[Dict[str, str]] = field(default_factory=dict)


@dataclass
class EndpointConditions(HikaruBase):
    r"""
    EndpointConditions represents the current condition of an endpoint.

    Full name: EndpointConditions

    Attributes:
    ready: ready indicates that this endpoint is prepared to receive traffic, according to
        whatever system is managing the endpoint. A nil value indicates an unknown state.
        In most cases consumers should interpret this unknown state as ready. For
        compatibility reasons, ready should never be "true" for terminating endpoints.
    serving: serving is identical to ready except that it is set regardless of the
        terminating state of endpoints. This condition should be set to true for a ready
        endpoint that is terminating. If nil, consumers should defer to the ready
        condition. This field can be enabled with the EndpointSliceTerminatingCondition
        feature gate.
    terminating: terminating indicates that this endpoint is terminating. A nil value
        indicates an unknown state. Consumers should interpret this unknown state to mean
        that the endpoint is not terminating. This field can be enabled with the
        EndpointSliceTerminatingCondition feature gate.
    """

    ready: Optional[bool] = None
    serving: Optional[bool] = None
    terminating: Optional[bool] = None


@dataclass
class EndpointHints(HikaruBase):
    r"""
    EndpointHints provides hints describing how an endpoint should be consumed.

    Full name: EndpointHints

    Attributes:
    forZones: forZones indicates the zone(s) this endpoint should be consumed by to enable
        topology aware routing. May contain a maximum of 8 entries.
    """

    forZones: Optional[List["ForZone"]] = field(default_factory=list)


@dataclass
class EndpointPort(HikaruBase):
    r"""
    EndpointPort represents a Port used by an EndpointSlice

    Full name: EndpointPort

    Attributes:
    appProtocol: The application protocol for this port. This field follows standard
        Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service
        names (as per RFC-6335 and http://www.iana.org/assignments/service-names).
        Non-standard protocols should use prefixed names such as
        mycompany.com/my-custom-protocol.
    name: The name of this port. All ports in an EndpointSlice must have a unique name. If
        the EndpointSlice is dervied from a Kubernetes service, this corresponds to the
        Service.ports[].name. Name must either be an empty string or pass DNS_LABEL
        validation: * must be no more than 63 characters long. * must consist of lower
        case alphanumeric characters or '-'. * must start and end with an alphanumeric
        character. Default is empty string.
    port: The port number of the endpoint. If this is not specified, ports are not
        restricted and must be interpreted in the context of the specific consumer.
    protocol: The IP protocol for this port. Must be UDP, TCP, or SCTP. Default is TCP.
    """

    appProtocol: Optional[str] = None
    name: Optional[str] = None
    port: Optional[int] = None
    protocol: Optional[str] = None


@dataclass
class EndpointSlice(HikaruDocumentBase):
    r"""
    EndpointSlice represents a subset of the endpoints that implement a service. For a
    given service there may be multiple EndpointSlice objects, selected by labels, which
    must be joined to produce the full set of endpoints.

    Full name: EndpointSlice

    Attributes:
    addressType: addressType specifies the type of address carried by this EndpointSlice.
        All addresses in this slice must be the same type. This field is immutable after
        creation. The following address types are currently supported: * IPv4: Represents
        an IPv4 Address. * IPv6: Represents an IPv6 Address. * FQDN: Represents a Fully
        Qualified Domain Name.
    endpoints: endpoints is a list of unique endpoints in this slice. Each slice may
        include a maximum of 1000 endpoints.
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata: Standard object's metadata.
    ports: ports specifies the list of network ports exposed by each endpoint in this
        slice. Each port must have a unique name. When ports is empty, it indicates that
        there are no defined ports. When a port is defined with a nil port value, it
        indicates "all ports". Each slice may include a maximum of 100 ports.
    """

    _version = "v1beta1"
    addressType: str
    endpoints: List["Endpoint"]
    apiVersion: Optional[str] = "discovery.k8s.io/v1beta1"
    kind: Optional[str] = "EndpointSlice"
    metadata: Optional["ObjectMeta"] = None
    ports: Optional[List["EndpointPort"]] = field(default_factory=list)
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def deleteCollectionNamespacedEndpointSlice(
        namespace: str,
        continue_: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_selector: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["EndpointSlice"]:
        r"""
        delete collection of EndpointSlice

        operationID: deleteCollectionNamespacedEndpointSlice
        path: /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices

        :param namespace: namespace for the resource
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Status    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = DiscoveryV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "delete_collection_namespaced_endpoint_slice_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_collection_namespaced_endpoint_slice_with_http_info "
                "on DiscoveryV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["namespace"] = namespace
        all_args["_continue"] = continue_
        all_args["dry_run"] = dry_run
        all_args["field_selector"] = field_selector
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["EndpointSlice"] = Response["EndpointSlice"](
            result, codes_returning_objects
        )
        return resp

    def createNamespacedEndpointSlice(
        self,
        namespace: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["EndpointSlice"]:
        r"""
        create an EndpointSlice

        operationID: createNamespacedEndpointSlice
        path: /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices

        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   EndpointSlice    OK
          201   EndpointSlice    Created
          202   EndpointSlice    Accepted
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = DiscoveryV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "create_namespaced_endpoint_slice_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "create_namespaced_endpoint_slice_with_http_info "
                "on DiscoveryV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201, 202)
        resp: Response["EndpointSlice"] = Response["EndpointSlice"](
            result, codes_returning_objects
        )
        return resp

    def create(
        self,
        namespace: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
    ) -> "EndpointSlice":
        r"""
            create an EndpointSlice

            operationID: createNamespacedEndpointSlice
            path: /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices

            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint.
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to create() or in a "
                "EndpointSlice's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace
        res = self.createNamespacedEndpointSlice(
            namespace=effective_namespace,
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    @staticmethod
    def deleteNamespacedEndpointSlice(
        name: str,
        namespace: str,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["EndpointSlice"]:
        r"""
        delete an EndpointSlice

        operationID: deleteNamespacedEndpointSlice
        path: /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Status    OK
          202   Status    Accepted
          401   None    Unauthorized
        """
        client_to_use = client
        inst = DiscoveryV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "delete_namespaced_endpoint_slice_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_namespaced_endpoint_slice_with_http_info "
                "on DiscoveryV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 202)
        resp: Response["EndpointSlice"] = Response["EndpointSlice"](
            result, codes_returning_objects
        )
        return resp

    def delete(
        self,
        name: Optional[str] = None,
        namespace: Optional[str] = None,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        client: ApiClient = None,
    ) -> "EndpointSlice":
        r"""
            delete an EndpointSlice

            operationID: deleteNamespacedEndpointSlice
            path: /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param grace_period_seconds: The duration in seconds before the object should
                be deleted. Value must be non-negative integer. The value zero
                indicates delete immediately. If this value is nil, the default
                grace period for the specified type will be used. Defaults to a per
                object value if not specified. zero means delete immediately.
            :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
                field will be deprecated in 1.7. Should the dependent objects be
                orphaned. If true/false, the "orphan" finalizer will be added
                to/removed from the object's finalizers list. Either this field or
                PropagationPolicy may be set, but not both.
            :param propagation_policy: Whether and how garbage collection will be
                performed. Either this field or OrphanDependents may be set, but not
                both. The default policy is decided by the existing finalizer set in
                the metadata.finalizers and the resource-specific default policy.
                Acceptable values are: 'Orphan' - orphan the dependents;
                'Background' - allow the garbage collector to delete the dependents
                in the background; 'Foreground' - a cascading policy that deletes
                all dependents in the foreground.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to delete() or in a "
                "EndpointSlice's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to delete() or in a "
                "EndpointSlice's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.deleteNamespacedEndpointSlice(
            name=effective_name,
            namespace=effective_namespace,
            dry_run=dry_run,
            grace_period_seconds=grace_period_seconds,
            orphan_dependents=orphan_dependents,
            propagation_policy=propagation_policy,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    @staticmethod
    def readNamespacedEndpointSlice(
        name: str,
        namespace: str,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["EndpointSlice"]:
        r"""
        read the specified EndpointSlice

        operationID: readNamespacedEndpointSlice
        path: /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   EndpointSlice    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = DiscoveryV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "read_namespaced_endpoint_slice_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "read_namespaced_endpoint_slice_with_http_info "
                "on DiscoveryV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["EndpointSlice"] = Response["EndpointSlice"](
            result, codes_returning_objects
        )
        return resp

    def read(
        self,
        name: Optional[str] = None,
        namespace: Optional[str] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
    ) -> "EndpointSlice":
        r"""
            read the specified EndpointSlice

            operationID: readNamespacedEndpointSlice
            path: /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param pretty: If 'true', then the output is pretty printed.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to read() or in a "
                "EndpointSlice's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to read() or in a "
                "EndpointSlice's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.readNamespacedEndpointSlice(
            name=effective_name,
            namespace=effective_namespace,
            pretty=pretty,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    def patchNamespacedEndpointSlice(
        self,
        name: str,
        namespace: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["EndpointSlice"]:
        r"""
        partially update the specified EndpointSlice

        operationID: patchNamespacedEndpointSlice
        path: /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint. This field is
            required for apply requests (application/apply-patch) but optional
            for non-apply patch types (JsonPatch, MergePatch,
            StrategicMergePatch).
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param force: Force is going to "force" Apply requests. It means user will
            re-acquire conflicting fields owned by other people. Force flag must
            be unset for non-apply patch requests.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   EndpointSlice    OK
          201   EndpointSlice    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = DiscoveryV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "patch_namespaced_endpoint_slice_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "patch_namespaced_endpoint_slice_with_http_info "
                "on DiscoveryV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        all_args["force"] = force
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["EndpointSlice"] = Response["EndpointSlice"](
            result, codes_returning_objects
        )
        return resp

    def update(
        self,
        namespace: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
    ) -> "EndpointSlice":
        r"""
            partially update the specified EndpointSlice

            operationID: patchNamespacedEndpointSlice
            path: /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}

            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint. This field is
                required for apply requests (application/apply-patch) but optional
                for non-apply patch types (JsonPatch, MergePatch,
                StrategicMergePatch).
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param force: Force is going to "force" Apply requests. It means user will
                re-acquire conflicting fields owned by other people. Force flag must
                be unset for non-apply patch requests.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to update() or in a "
                "EndpointSlice's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace
        res = self.patchNamespacedEndpointSlice(
            name=self.metadata.name,
            namespace=effective_namespace,
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            force=force,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    def __enter__(self):
        return self

    def __exit__(self, ex_type, ex_value, ex_traceback):
        passed = ex_type is None and ex_value is None and ex_traceback is None
        has_rollback = hasattr(self, "__rollback")
        if passed:
            try:
                self.update()
            except Exception:
                if has_rollback:
                    self.merge(getattr(self, "__rollback"), overwrite=True)
                    delattr(self, "__rollback")
                raise
        if has_rollback:
            if not passed:
                self.merge(getattr(self, "__rollback"), overwrite=True)
            delattr(self, "__rollback")
        return False

    def replaceNamespacedEndpointSlice(
        self,
        name: str,
        namespace: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["EndpointSlice"]:
        r"""
        replace the specified EndpointSlice

        operationID: replaceNamespacedEndpointSlice
        path: /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   EndpointSlice    OK
          201   EndpointSlice    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = DiscoveryV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "replace_namespaced_endpoint_slice_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "replace_namespaced_endpoint_slice_with_http_info "
                "on DiscoveryV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["EndpointSlice"] = Response["EndpointSlice"](
            result, codes_returning_objects
        )
        return resp


@dataclass
class EndpointSliceList(HikaruDocumentBase):
    r"""
    EndpointSliceList represents a list of endpoint slices

    Full name: EndpointSliceList

    Attributes:
    items: List of endpoint slices
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata: Standard list metadata.
    """

    _version = "v1beta1"
    items: List["EndpointSlice"]
    apiVersion: Optional[str] = "discovery.k8s.io/v1beta1"
    kind: Optional[str] = "EndpointSliceList"
    metadata: Optional["ListMeta"] = None
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def listEndpointSliceForAllNamespaces(
        allow_watch_bookmarks: Optional[bool] = None,
        continue_: Optional[str] = None,
        field_selector: Optional[str] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        pretty: Optional[str] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        watch: Optional[bool] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["EndpointSliceList"]:
        r"""
        list or watch objects of kind EndpointSlice

        operationID: listEndpointSliceForAllNamespaces
        path: /apis/discovery.k8s.io/v1beta1/endpointslices

        :param allow_watch_bookmarks: allowWatchBookmarks requests watch events with
            type "BOOKMARK". Servers that do not implement bookmarks may ignore
            this flag and bookmarks are sent at the server's discretion. Clients
            should not assume bookmarks are returned at any specific interval,
            nor may they assume the server will send any BOOKMARK event during a
            session. If this is not a watch, this field is ignored.
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param pretty: If 'true', then the output is pretty printed.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param watch: Watch for changes to the described resources and return them as a
            stream of add, update, and remove notifications. Specify
            resourceVersion.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   EndpointSliceList    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = DiscoveryV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "list_endpoint_slice_for_all_namespaces_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "list_endpoint_slice_for_all_namespaces_with_http_info "
                "on DiscoveryV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["allow_watch_bookmarks"] = allow_watch_bookmarks
        all_args["_continue"] = continue_
        all_args["field_selector"] = field_selector
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["pretty"] = pretty
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["watch"] = watch
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["EndpointSliceList"] = Response["EndpointSliceList"](
            result, codes_returning_objects
        )
        return resp

    _watcher = WatcherDescriptor(
        "kubernetes.client.api",
        ".discovery_v1beta1_api",
        "DiscoveryV1beta1Api",
        "list_endpoint_slice_for_all_namespaces",
    )

    @staticmethod
    def listNamespacedEndpointSlice(
        namespace: str,
        allow_watch_bookmarks: Optional[bool] = None,
        continue_: Optional[str] = None,
        field_selector: Optional[str] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        watch: Optional[bool] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["EndpointSliceList"]:
        r"""
        list or watch objects of kind EndpointSlice

        operationID: listNamespacedEndpointSlice
        path: /apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices

        :param namespace: namespace for the resource
        :param allow_watch_bookmarks: allowWatchBookmarks requests watch events with
            type "BOOKMARK". Servers that do not implement bookmarks may ignore
            this flag and bookmarks are sent at the server's discretion. Clients
            should not assume bookmarks are returned at any specific interval,
            nor may they assume the server will send any BOOKMARK event during a
            session. If this is not a watch, this field is ignored.
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param watch: Watch for changes to the described resources and return them as a
            stream of add, update, and remove notifications. Specify
            resourceVersion.
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   EndpointSliceList    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = DiscoveryV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "list_namespaced_endpoint_slice_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "list_namespaced_endpoint_slice_with_http_info "
                "on DiscoveryV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["namespace"] = namespace
        all_args["allow_watch_bookmarks"] = allow_watch_bookmarks
        all_args["_continue"] = continue_
        all_args["field_selector"] = field_selector
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["watch"] = watch
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["EndpointSliceList"] = Response["EndpointSliceList"](
            result, codes_returning_objects
        )
        return resp

    _namespaced_watcher = WatcherDescriptor(
        "kubernetes.client.api",
        ".discovery_v1beta1_api",
        "DiscoveryV1beta1Api",
        "list_namespaced_endpoint_slice",
    )


@dataclass
class ForZone(HikaruBase):
    r"""
    ForZone provides information about which zones should consume this endpoint.

    Full name: ForZone

    Attributes:
    name: name represents the name of the zone.
    """

    name: str


@dataclass
class Event(HikaruDocumentBase):
    r"""
    Event is a report of an event somewhere in the cluster. It generally denotes some
    state change in the system. Events have a limited retention time and triggers and
    messages may evolve with time. Event consumers should not rely on the timing of an
    event with a given Reason reflecting a consistent underlying trigger, or the continued
    existence of events with that Reason. Events should be treated as informative,
    best-effort, supplemental data.

    Full name: Event

    Attributes:
    eventTime: eventTime is the time when this Event was first observed. It is required.
    action: action is what action was taken/failed regarding to the regarding object. It
        is machine-readable. This field can have at most 128 characters.
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    deprecatedCount: deprecatedCount is the deprecated field assuring backward
        compatibility with core.v1 Event type.
    deprecatedFirstTimestamp: deprecatedFirstTimestamp is the deprecated field assuring
        backward compatibility with core.v1 Event type.
    deprecatedLastTimestamp: deprecatedLastTimestamp is the deprecated field assuring
        backward compatibility with core.v1 Event type.
    deprecatedSource: deprecatedSource is the deprecated field assuring backward
        compatibility with core.v1 Event type.
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata: Standard object's metadata. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    note: note is a human-readable description of the status of this operation. Maximal
        length of the note is 1kB, but libraries should be prepared to handle values up to
        64kB.
    reason: reason is why the action was taken. It is human-readable. This field can have
        at most 128 characters.
    regarding: regarding contains the object this Event is about. In most cases it's an
        Object reporting controller implements, e.g. ReplicaSetController implements
        ReplicaSets and this event is emitted because it acts on some changes in a
        ReplicaSet object.
    related: related is the optional secondary object for more complex actions. E.g. when
        regarding object triggers a creation or deletion of related object.
    reportingController: reportingController is the name of the controller that emitted
        this Event, e.g. `kubernetes.io/kubelet`. This field cannot be empty for new
        Events.
    reportingInstance: reportingInstance is the ID of the controller instance, e.g.
        `kubelet-xyzf`. This field cannot be empty for new Events and it can have at most
        128 characters.
    series: series is data about the Event series this event represents or nil if it's a
        singleton Event.
    type: type is the type of this event (Normal, Warning), new types could be added in
        the future. It is machine-readable.
    """

    _version = "v1beta1"
    eventTime: str
    action: Optional[str] = None
    apiVersion: Optional[str] = "events.k8s.io/v1beta1"
    deprecatedCount: Optional[int] = None
    deprecatedFirstTimestamp: Optional[str] = None
    deprecatedLastTimestamp: Optional[str] = None
    deprecatedSource: Optional["EventSource"] = None
    kind: Optional[str] = "Event"
    metadata: Optional["ObjectMeta"] = None
    note: Optional[str] = None
    reason: Optional[str] = None
    regarding: Optional["ObjectReference"] = None
    related: Optional["ObjectReference"] = None
    reportingController: Optional[str] = None
    reportingInstance: Optional[str] = None
    series: Optional["EventSeries"] = None
    type: Optional[str] = None
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def deleteCollectionNamespacedEvent(
        namespace: str,
        continue_: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_selector: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["Event"]:
        r"""
        delete collection of Event

        operationID: deleteCollectionNamespacedEvent
        path: /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events

        :param namespace: namespace for the resource
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Status    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = EventsV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "delete_collection_namespaced_event_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_collection_namespaced_event_with_http_info "
                "on EventsV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["namespace"] = namespace
        all_args["_continue"] = continue_
        all_args["dry_run"] = dry_run
        all_args["field_selector"] = field_selector
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["Event"] = Response["Event"](result, codes_returning_objects)
        return resp

    def createNamespacedEvent(
        self,
        namespace: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["Event"]:
        r"""
        create an Event

        operationID: createNamespacedEvent
        path: /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events

        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Event    OK
          201   Event    Created
          202   Event    Accepted
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = EventsV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "create_namespaced_event_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "create_namespaced_event_with_http_info "
                "on EventsV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201, 202)
        resp: Response["Event"] = Response["Event"](result, codes_returning_objects)
        return resp

    def create(
        self,
        namespace: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
    ) -> "Event":
        r"""
            create an Event

            operationID: createNamespacedEvent
            path: /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events

            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint.
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to create() or in a "
                "Event's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace
        res = self.createNamespacedEvent(
            namespace=effective_namespace,
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    @staticmethod
    def deleteNamespacedEvent(
        name: str,
        namespace: str,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["Event"]:
        r"""
        delete an Event

        operationID: deleteNamespacedEvent
        path: /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Status    OK
          202   Status    Accepted
          401   None    Unauthorized
        """
        client_to_use = client
        inst = EventsV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "delete_namespaced_event_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_namespaced_event_with_http_info "
                "on EventsV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 202)
        resp: Response["Event"] = Response["Event"](result, codes_returning_objects)
        return resp

    def delete(
        self,
        name: Optional[str] = None,
        namespace: Optional[str] = None,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        client: ApiClient = None,
    ) -> "Event":
        r"""
            delete an Event

            operationID: deleteNamespacedEvent
            path: /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param grace_period_seconds: The duration in seconds before the object should
                be deleted. Value must be non-negative integer. The value zero
                indicates delete immediately. If this value is nil, the default
                grace period for the specified type will be used. Defaults to a per
                object value if not specified. zero means delete immediately.
            :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
                field will be deprecated in 1.7. Should the dependent objects be
                orphaned. If true/false, the "orphan" finalizer will be added
                to/removed from the object's finalizers list. Either this field or
                PropagationPolicy may be set, but not both.
            :param propagation_policy: Whether and how garbage collection will be
                performed. Either this field or OrphanDependents may be set, but not
                both. The default policy is decided by the existing finalizer set in
                the metadata.finalizers and the resource-specific default policy.
                Acceptable values are: 'Orphan' - orphan the dependents;
                'Background' - allow the garbage collector to delete the dependents
                in the background; 'Foreground' - a cascading policy that deletes
                all dependents in the foreground.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to delete() or in a "
                "Event's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to delete() or in a "
                "Event's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.deleteNamespacedEvent(
            name=effective_name,
            namespace=effective_namespace,
            dry_run=dry_run,
            grace_period_seconds=grace_period_seconds,
            orphan_dependents=orphan_dependents,
            propagation_policy=propagation_policy,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    @staticmethod
    def readNamespacedEvent(
        name: str,
        namespace: str,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["Event"]:
        r"""
        read the specified Event

        operationID: readNamespacedEvent
        path: /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Event    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = EventsV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "read_namespaced_event_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "read_namespaced_event_with_http_info "
                "on EventsV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["Event"] = Response["Event"](result, codes_returning_objects)
        return resp

    def read(
        self,
        name: Optional[str] = None,
        namespace: Optional[str] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
    ) -> "Event":
        r"""
            read the specified Event

            operationID: readNamespacedEvent
            path: /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param pretty: If 'true', then the output is pretty printed.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to read() or in a "
                "Event's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to read() or in a "
                "Event's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.readNamespacedEvent(
            name=effective_name,
            namespace=effective_namespace,
            pretty=pretty,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    def patchNamespacedEvent(
        self,
        name: str,
        namespace: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["Event"]:
        r"""
        partially update the specified Event

        operationID: patchNamespacedEvent
        path: /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint. This field is
            required for apply requests (application/apply-patch) but optional
            for non-apply patch types (JsonPatch, MergePatch,
            StrategicMergePatch).
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param force: Force is going to "force" Apply requests. It means user will
            re-acquire conflicting fields owned by other people. Force flag must
            be unset for non-apply patch requests.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Event    OK
          201   Event    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = EventsV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "patch_namespaced_event_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "patch_namespaced_event_with_http_info "
                "on EventsV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        all_args["force"] = force
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["Event"] = Response["Event"](result, codes_returning_objects)
        return resp

    def update(
        self,
        namespace: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
    ) -> "Event":
        r"""
            partially update the specified Event

            operationID: patchNamespacedEvent
            path: /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}

            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint. This field is
                required for apply requests (application/apply-patch) but optional
                for non-apply patch types (JsonPatch, MergePatch,
                StrategicMergePatch).
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param force: Force is going to "force" Apply requests. It means user will
                re-acquire conflicting fields owned by other people. Force flag must
                be unset for non-apply patch requests.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to update() or in a "
                "Event's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace
        res = self.patchNamespacedEvent(
            name=self.metadata.name,
            namespace=effective_namespace,
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            force=force,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    def __enter__(self):
        return self

    def __exit__(self, ex_type, ex_value, ex_traceback):
        passed = ex_type is None and ex_value is None and ex_traceback is None
        has_rollback = hasattr(self, "__rollback")
        if passed:
            try:
                self.update()
            except Exception:
                if has_rollback:
                    self.merge(getattr(self, "__rollback"), overwrite=True)
                    delattr(self, "__rollback")
                raise
        if has_rollback:
            if not passed:
                self.merge(getattr(self, "__rollback"), overwrite=True)
            delattr(self, "__rollback")
        return False

    def replaceNamespacedEvent(
        self,
        name: str,
        namespace: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["Event"]:
        r"""
        replace the specified Event

        operationID: replaceNamespacedEvent
        path: /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Event    OK
          201   Event    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = EventsV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "replace_namespaced_event_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "replace_namespaced_event_with_http_info "
                "on EventsV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["Event"] = Response["Event"](result, codes_returning_objects)
        return resp


@dataclass
class EventList(HikaruDocumentBase):
    r"""
    EventList is a list of Event objects.

    Full name: EventList

    Attributes:
    items: items is a list of schema objects.
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata: Standard list metadata. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    """

    _version = "v1beta1"
    items: List["Event"]
    apiVersion: Optional[str] = "events.k8s.io/v1beta1"
    kind: Optional[str] = "EventList"
    metadata: Optional["ListMeta"] = None
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def listEventForAllNamespaces(
        allow_watch_bookmarks: Optional[bool] = None,
        continue_: Optional[str] = None,
        field_selector: Optional[str] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        pretty: Optional[str] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        watch: Optional[bool] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["EventList"]:
        r"""
        list or watch objects of kind Event

        operationID: listEventForAllNamespaces
        path: /apis/events.k8s.io/v1beta1/events

        :param allow_watch_bookmarks: allowWatchBookmarks requests watch events with
            type "BOOKMARK". Servers that do not implement bookmarks may ignore
            this flag and bookmarks are sent at the server's discretion. Clients
            should not assume bookmarks are returned at any specific interval,
            nor may they assume the server will send any BOOKMARK event during a
            session. If this is not a watch, this field is ignored.
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param pretty: If 'true', then the output is pretty printed.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param watch: Watch for changes to the described resources and return them as a
            stream of add, update, and remove notifications. Specify
            resourceVersion.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   EventList    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = EventsV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "list_event_for_all_namespaces_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "list_event_for_all_namespaces_with_http_info "
                "on EventsV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["allow_watch_bookmarks"] = allow_watch_bookmarks
        all_args["_continue"] = continue_
        all_args["field_selector"] = field_selector
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["pretty"] = pretty
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["watch"] = watch
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["EventList"] = Response["EventList"](
            result, codes_returning_objects
        )
        return resp

    _watcher = WatcherDescriptor(
        "kubernetes.client.api",
        ".events_v1beta1_api",
        "EventsV1beta1Api",
        "list_event_for_all_namespaces",
    )

    @staticmethod
    def listNamespacedEvent(
        namespace: str,
        allow_watch_bookmarks: Optional[bool] = None,
        continue_: Optional[str] = None,
        field_selector: Optional[str] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        watch: Optional[bool] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["EventList"]:
        r"""
        list or watch objects of kind Event

        operationID: listNamespacedEvent
        path: /apis/events.k8s.io/v1beta1/namespaces/{namespace}/events

        :param namespace: namespace for the resource
        :param allow_watch_bookmarks: allowWatchBookmarks requests watch events with
            type "BOOKMARK". Servers that do not implement bookmarks may ignore
            this flag and bookmarks are sent at the server's discretion. Clients
            should not assume bookmarks are returned at any specific interval,
            nor may they assume the server will send any BOOKMARK event during a
            session. If this is not a watch, this field is ignored.
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param watch: Watch for changes to the described resources and return them as a
            stream of add, update, and remove notifications. Specify
            resourceVersion.
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   EventList    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = EventsV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "list_namespaced_event_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "list_namespaced_event_with_http_info "
                "on EventsV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["namespace"] = namespace
        all_args["allow_watch_bookmarks"] = allow_watch_bookmarks
        all_args["_continue"] = continue_
        all_args["field_selector"] = field_selector
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["watch"] = watch
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["EventList"] = Response["EventList"](
            result, codes_returning_objects
        )
        return resp

    _namespaced_watcher = WatcherDescriptor(
        "kubernetes.client.api",
        ".events_v1beta1_api",
        "EventsV1beta1Api",
        "list_namespaced_event",
    )


@dataclass
class EventSeries(HikaruBase):
    r"""
    EventSeries contain information on series of events, i.e. thing that was/is happening
    continuously for some time.

    Full name: EventSeries

    Attributes:
    count: count is the number of occurrences in this series up to the last heartbeat
        time.
    lastObservedTime: lastObservedTime is the time when last Event from the series was
        seen before last heartbeat.
    """

    count: int
    lastObservedTime: str


@dataclass
class FlowDistinguisherMethod(HikaruBase):
    r"""
    FlowDistinguisherMethod specifies the method of a flow distinguisher.

    Full name: FlowDistinguisherMethod

    Attributes:
    type: `type` is the type of flow distinguisher method The supported types are "ByUser"
        and "ByNamespace". Required.
    """

    type: str


@dataclass
class FlowSchema(HikaruDocumentBase):
    r"""
    FlowSchema defines the schema of a group of flows. Note that a flow is made up of a
    set of inbound API requests with similar attributes and is identified by a pair of
    strings: the name of the FlowSchema and a "flow distinguisher".

    Full name: FlowSchema

    Attributes:
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata: `metadata` is the standard object's metadata. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    spec: `spec` is the specification of the desired behavior of a FlowSchema. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    status: `status` is the current status of a FlowSchema. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    """

    _version = "v1beta1"
    apiVersion: Optional[str] = "flowcontrol.apiserver.k8s.io/v1beta1"
    kind: Optional[str] = "FlowSchema"
    metadata: Optional["ObjectMeta"] = None
    spec: Optional["FlowSchemaSpec"] = None
    status: Optional["FlowSchemaStatus"] = None
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def deleteCollectionFlowSchema(
        continue_: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_selector: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["FlowSchema"]:
        r"""
        delete collection of FlowSchema

        operationID: deleteCollectionFlowSchema
        path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas

        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Status    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = FlowcontrolApiserverV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "delete_collection_flow_schema_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_collection_flow_schema_with_http_info "
                "on FlowcontrolApiserverV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["_continue"] = continue_
        all_args["dry_run"] = dry_run
        all_args["field_selector"] = field_selector
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["FlowSchema"] = Response["FlowSchema"](
            result, codes_returning_objects
        )
        return resp

    def createFlowSchema(
        self,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["FlowSchema"]:
        r"""
        create a FlowSchema

        operationID: createFlowSchema
        path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas

        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   FlowSchema    OK
          201   FlowSchema    Created
          202   FlowSchema    Accepted
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = FlowcontrolApiserverV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "create_flow_schema_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "create_flow_schema_with_http_info "
                "on FlowcontrolApiserverV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201, 202)
        resp: Response["FlowSchema"] = Response["FlowSchema"](
            result, codes_returning_objects
        )
        return resp

    def create(
        self,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
    ) -> "FlowSchema":
        r"""
            create a FlowSchema

            operationID: createFlowSchema
            path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas

            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint.
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        res = self.createFlowSchema(
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    @staticmethod
    def deleteFlowSchema(
        name: str,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["FlowSchema"]:
        r"""
        delete a FlowSchema

        operationID: deleteFlowSchema
        path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}

        :param name: name for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Status    OK
          202   Status    Accepted
          401   None    Unauthorized
        """
        client_to_use = client
        inst = FlowcontrolApiserverV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "delete_flow_schema_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_flow_schema_with_http_info "
                "on FlowcontrolApiserverV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["dry_run"] = dry_run
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 202)
        resp: Response["FlowSchema"] = Response["FlowSchema"](
            result, codes_returning_objects
        )
        return resp

    def delete(
        self,
        name: Optional[str] = None,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        client: ApiClient = None,
    ) -> "FlowSchema":
        r"""
            delete a FlowSchema

            operationID: deleteFlowSchema
            path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param grace_period_seconds: The duration in seconds before the object should
                be deleted. Value must be non-negative integer. The value zero
                indicates delete immediately. If this value is nil, the default
                grace period for the specified type will be used. Defaults to a per
                object value if not specified. zero means delete immediately.
            :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
                field will be deprecated in 1.7. Should the dependent objects be
                orphaned. If true/false, the "orphan" finalizer will be added
                to/removed from the object's finalizers list. Either this field or
                PropagationPolicy may be set, but not both.
            :param propagation_policy: Whether and how garbage collection will be
                performed. Either this field or OrphanDependents may be set, but not
                both. The default policy is decided by the existing finalizer set in
                the metadata.finalizers and the resource-specific default policy.
                Acceptable values are: 'Orphan' - orphan the dependents;
                'Background' - allow the garbage collector to delete the dependents
                in the background; 'Foreground' - a cascading policy that deletes
                all dependents in the foreground.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to delete() or in a "
                "FlowSchema's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.deleteFlowSchema(
            name=effective_name,
            dry_run=dry_run,
            grace_period_seconds=grace_period_seconds,
            orphan_dependents=orphan_dependents,
            propagation_policy=propagation_policy,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    @staticmethod
    def readFlowSchema(
        name: str,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["FlowSchema"]:
        r"""
        read the specified FlowSchema

        operationID: readFlowSchema
        path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}

        :param name: name for the resource
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   FlowSchema    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = FlowcontrolApiserverV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "read_flow_schema_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "read_flow_schema_with_http_info "
                "on FlowcontrolApiserverV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["FlowSchema"] = Response["FlowSchema"](
            result, codes_returning_objects
        )
        return resp

    def read(
        self,
        name: Optional[str] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
    ) -> "FlowSchema":
        r"""
            read the specified FlowSchema

            operationID: readFlowSchema
            path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param pretty: If 'true', then the output is pretty printed.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to read() or in a "
                "FlowSchema's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.readFlowSchema(name=effective_name, pretty=pretty, client=client)
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    def patchFlowSchema(
        self,
        name: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["FlowSchema"]:
        r"""
        partially update the specified FlowSchema

        operationID: patchFlowSchema
        path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}

        :param name: name for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint. This field is
            required for apply requests (application/apply-patch) but optional
            for non-apply patch types (JsonPatch, MergePatch,
            StrategicMergePatch).
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param force: Force is going to "force" Apply requests. It means user will
            re-acquire conflicting fields owned by other people. Force flag must
            be unset for non-apply patch requests.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   FlowSchema    OK
          201   FlowSchema    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = FlowcontrolApiserverV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "patch_flow_schema_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "patch_flow_schema_with_http_info "
                "on FlowcontrolApiserverV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        all_args["force"] = force
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["FlowSchema"] = Response["FlowSchema"](
            result, codes_returning_objects
        )
        return resp

    def update(
        self,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
    ) -> "FlowSchema":
        r"""
            partially update the specified FlowSchema

            operationID: patchFlowSchema
            path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}

            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint. This field is
                required for apply requests (application/apply-patch) but optional
                for non-apply patch types (JsonPatch, MergePatch,
                StrategicMergePatch).
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param force: Force is going to "force" Apply requests. It means user will
                re-acquire conflicting fields owned by other people. Force flag must
                be unset for non-apply patch requests.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        res = self.patchFlowSchema(
            name=self.metadata.name,
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            force=force,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    def __enter__(self):
        return self

    def __exit__(self, ex_type, ex_value, ex_traceback):
        passed = ex_type is None and ex_value is None and ex_traceback is None
        has_rollback = hasattr(self, "__rollback")
        if passed:
            try:
                self.update()
            except Exception:
                if has_rollback:
                    self.merge(getattr(self, "__rollback"), overwrite=True)
                    delattr(self, "__rollback")
                raise
        if has_rollback:
            if not passed:
                self.merge(getattr(self, "__rollback"), overwrite=True)
            delattr(self, "__rollback")
        return False

    def replaceFlowSchema(
        self,
        name: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["FlowSchema"]:
        r"""
        replace the specified FlowSchema

        operationID: replaceFlowSchema
        path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}

        :param name: name for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   FlowSchema    OK
          201   FlowSchema    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = FlowcontrolApiserverV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "replace_flow_schema_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "replace_flow_schema_with_http_info "
                "on FlowcontrolApiserverV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["FlowSchema"] = Response["FlowSchema"](
            result, codes_returning_objects
        )
        return resp

    def replaceFlowSchemaStatus(
        self,
        name: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["FlowSchema"]:
        r"""
        replace status of the specified FlowSchema

        operationID: replaceFlowSchemaStatus
        path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas/{name}/status

        :param name: name for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   FlowSchema    OK
          201   FlowSchema    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = FlowcontrolApiserverV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "replace_flow_schema_status_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "replace_flow_schema_status_with_http_info "
                "on FlowcontrolApiserverV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["FlowSchema"] = Response["FlowSchema"](
            result, codes_returning_objects
        )
        return resp


@dataclass
class FlowSchemaCondition(HikaruBase):
    r"""
    FlowSchemaCondition describes conditions for a FlowSchema.

    Full name: FlowSchemaCondition

    Attributes:
    lastTransitionTime: `lastTransitionTime` is the last time the condition transitioned
        from one status to another.
    message: `message` is a human-readable message indicating details about last
        transition.
    reason: `reason` is a unique, one-word, CamelCase reason for the condition's last
        transition.
    status: `status` is the status of the condition. Can be True, False, Unknown.
        Required.
    type: `type` is the type of the condition. Required.
    """

    lastTransitionTime: Optional[str] = None
    message: Optional[str] = None
    reason: Optional[str] = None
    status: Optional[str] = None
    type: Optional[str] = None


@dataclass
class FlowSchemaList(HikaruDocumentBase):
    r"""
    FlowSchemaList is a list of FlowSchema objects.

    Full name: FlowSchemaList

    Attributes:
    items: `items` is a list of FlowSchemas.
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata: `metadata` is the standard list metadata. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    """

    _version = "v1beta1"
    items: List["FlowSchema"]
    apiVersion: Optional[str] = "flowcontrol.apiserver.k8s.io/v1beta1"
    kind: Optional[str] = "FlowSchemaList"
    metadata: Optional["ListMeta"] = None
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def listFlowSchema(
        allow_watch_bookmarks: Optional[bool] = None,
        continue_: Optional[str] = None,
        field_selector: Optional[str] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        watch: Optional[bool] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["FlowSchemaList"]:
        r"""
        list or watch objects of kind FlowSchema

        operationID: listFlowSchema
        path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/flowschemas

        :param allow_watch_bookmarks: allowWatchBookmarks requests watch events with
            type "BOOKMARK". Servers that do not implement bookmarks may ignore
            this flag and bookmarks are sent at the server's discretion. Clients
            should not assume bookmarks are returned at any specific interval,
            nor may they assume the server will send any BOOKMARK event during a
            session. If this is not a watch, this field is ignored.
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param watch: Watch for changes to the described resources and return them as a
            stream of add, update, and remove notifications. Specify
            resourceVersion.
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   FlowSchemaList    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = FlowcontrolApiserverV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "list_flow_schema_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "list_flow_schema_with_http_info "
                "on FlowcontrolApiserverV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["allow_watch_bookmarks"] = allow_watch_bookmarks
        all_args["_continue"] = continue_
        all_args["field_selector"] = field_selector
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["watch"] = watch
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["FlowSchemaList"] = Response["FlowSchemaList"](
            result, codes_returning_objects
        )
        return resp

    _watcher = WatcherDescriptor(
        "kubernetes.client.api",
        ".flowcontrol_apiserver_v1beta1_api",
        "FlowcontrolApiserverV1beta1Api",
        "list_flow_schema",
    )


@dataclass
class FlowSchemaSpec(HikaruBase):
    r"""
    FlowSchemaSpec describes how the FlowSchema's specification looks like.

    Full name: FlowSchemaSpec

    Attributes:
    priorityLevelConfiguration: `priorityLevelConfiguration` should reference a
        PriorityLevelConfiguration in the cluster. If the reference cannot be resolved,
        the FlowSchema will be ignored and marked as invalid in its status. Required.
    distinguisherMethod: `distinguisherMethod` defines how to compute the flow
        distinguisher for requests that match this schema. `nil` specifies that the
        distinguisher is disabled and thus will always be the empty string.
    matchingPrecedence: `matchingPrecedence` is used to choose among the FlowSchemas that
        match a given request. The chosen FlowSchema is among those with the numerically
        lowest (which we take to be logically highest) MatchingPrecedence. Each
        MatchingPrecedence value must be ranged in [1,10000]. Note that if the precedence
        is not specified, it will be set to 1000 as default.
    rules: `rules` describes which requests will match this flow schema. This FlowSchema
        matches a request if and only if at least one member of rules matches the request.
        if it is an empty slice, there will be no requests matching the FlowSchema.
    """

    priorityLevelConfiguration: "PriorityLevelConfigurationReference"
    distinguisherMethod: Optional["FlowDistinguisherMethod"] = None
    matchingPrecedence: Optional[int] = None
    rules: Optional[List["PolicyRulesWithSubjects"]] = field(default_factory=list)


@dataclass
class FlowSchemaStatus(HikaruBase):
    r"""
    FlowSchemaStatus represents the current state of a FlowSchema.

    Full name: FlowSchemaStatus

    Attributes:
    conditions: `conditions` is a list of the current states of FlowSchema.
    """

    conditions: Optional[List["FlowSchemaCondition"]] = field(default_factory=list)


@dataclass
class GroupSubject(HikaruBase):
    r"""
    GroupSubject holds detailed information for group-kind subject.

    Full name: GroupSubject

    Attributes:
    name: name is the user group that matches, or "*" to match all user groups. See
        https://github.com/kubernetes/apiserver/blob/master/pkg/authentication/user/user.go
        for some well-known group names. Required.
    """

    name: str


@dataclass
class LimitResponse(HikaruBase):
    r"""
    LimitResponse defines how to handle requests that can not be executed right now.

    Full name: LimitResponse

    Attributes:
    type: `type` is "Queue" or "Reject". "Queue" means that requests that can not be
        executed upon arrival are held in a queue until they can be executed or a queuing
        limit is reached. "Reject" means that requests that can not be executed upon
        arrival are rejected. Required.
    queuing: `queuing` holds the configuration parameters for queuing. This field may be
        non-empty only if `type` is `"Queue"`.
    """

    type: str
    queuing: Optional["QueuingConfiguration"] = None


@dataclass
class LimitedPriorityLevelConfiguration(HikaruBase):
    r"""
    LimitedPriorityLevelConfiguration specifies how to handle requests that are subject to
    limits. It addresses two issues: * How are requests for this priority level limited? *
    What should be done with requests that exceed the limit?

    Full name: LimitedPriorityLevelConfiguration

    Attributes:
    assuredConcurrencyShares: `assuredConcurrencyShares` (ACS) configures the execution
        limit, which is a limit on the number of requests of this priority level that may
        be exeucting at a given time. ACS must be a positive number. The server's
        concurrency limit (SCL) is divided among the concurrency-controlled priority
        levels in proportion to their assured concurrency shares. This produces the
        assured concurrency value (ACV) --- the number of requests that may be executing
        at a time --- for each such priority level: ACV(l) = ceil( SCL * ACS(l) / (
        sum[priority levels k] ACS(k) ) ) bigger numbers of ACS mean more reserved
        concurrent requests (at the expense of every other PL). This field has a default
        value of 30.
    limitResponse: `limitResponse` indicates what to do with requests that can not be
        executed right now
    """

    assuredConcurrencyShares: Optional[int] = None
    limitResponse: Optional["LimitResponse"] = None


@dataclass
class NonResourcePolicyRule(HikaruBase):
    r"""
    NonResourcePolicyRule is a predicate that matches non-resource requests according to
    their verb and the target non-resource URL. A NonResourcePolicyRule matches a request
    if and only if both (a) at least one member of verbs matches the request and (b) at
    least one member of nonResourceURLs matches the request.

    Full name: NonResourcePolicyRule

    Attributes:
    nonResourceURLs: `nonResourceURLs` is a set of url prefixes that a user should have
        access to and may not be empty. For example: - "/healthz" is legal - "/hea*" is
        illegal - "/hea" is legal but matches nothing - "/hea/*" also matches nothing -
        "/healthz/*" matches all per-component health checks. "*" matches all non-resource
        urls. if it is present, it must be the only entry. Required.
    verbs: `verbs` is a list of matching verbs and may not be empty. "*" matches all
        verbs. If it is present, it must be the only entry. Required.
    """

    nonResourceURLs: List[str]
    verbs: List[str]


@dataclass
class PolicyRulesWithSubjects(HikaruBase):
    r"""
    PolicyRulesWithSubjects prescribes a test that applies to a request to an apiserver.
    The test considers the subject making the request, the verb being requested, and the
    resource to be acted upon. This PolicyRulesWithSubjects matches a request if and only
    if both (a) at least one member of subjects matches the request and (b) at least one
    member of resourceRules or nonResourceRules matches the request.

    Full name: PolicyRulesWithSubjects

    Attributes:
    subjects: subjects is the list of normal user, serviceaccount, or group that this rule
        cares about. There must be at least one member in this slice. A slice that
        includes both the system:authenticated and system:unauthenticated user groups
        matches every request. Required.
    nonResourceRules: `nonResourceRules` is a list of NonResourcePolicyRules that identify
        matching requests according to their verb and the target non-resource URL.
    resourceRules: `resourceRules` is a slice of ResourcePolicyRules that identify
        matching requests according to their verb and the target resource. At least one of
        `resourceRules` and `nonResourceRules` has to be non-empty.
    """

    subjects: List["Subject"]
    nonResourceRules: Optional[List["NonResourcePolicyRule"]] = field(
        default_factory=list
    )
    resourceRules: Optional[List["ResourcePolicyRule"]] = field(default_factory=list)


@dataclass
class PriorityLevelConfiguration(HikaruDocumentBase):
    r"""
    PriorityLevelConfiguration represents the configuration of a priority level.

    Full name: PriorityLevelConfiguration

    Attributes:
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata: `metadata` is the standard object's metadata. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    spec: `spec` is the specification of the desired behavior of a "request-priority".
        More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    status: `status` is the current status of a "request-priority". More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    """

    _version = "v1beta1"
    apiVersion: Optional[str] = "flowcontrol.apiserver.k8s.io/v1beta1"
    kind: Optional[str] = "PriorityLevelConfiguration"
    metadata: Optional["ObjectMeta"] = None
    spec: Optional["PriorityLevelConfigurationSpec"] = None
    status: Optional["PriorityLevelConfigurationStatus"] = None
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def deleteCollectionPriorityLevelConfiguration(
        continue_: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_selector: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PriorityLevelConfiguration"]:
        r"""
        delete collection of PriorityLevelConfiguration

        operationID: deleteCollectionPriorityLevelConfiguration
        path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations

        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Status    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = FlowcontrolApiserverV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "delete_collection_priority_level_configuration_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_collection_priority_level_configuration_with_http_info "
                "on FlowcontrolApiserverV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["_continue"] = continue_
        all_args["dry_run"] = dry_run
        all_args["field_selector"] = field_selector
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["PriorityLevelConfiguration"] = Response[
            "PriorityLevelConfiguration"
        ](result, codes_returning_objects)
        return resp

    def createPriorityLevelConfiguration(
        self,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PriorityLevelConfiguration"]:
        r"""
        create a PriorityLevelConfiguration

        operationID: createPriorityLevelConfiguration
        path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations

        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PriorityLevelConfiguration    OK
          201   PriorityLevelConfiguration    Created
          202   PriorityLevelConfiguration    Accepted
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = FlowcontrolApiserverV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "create_priority_level_configuration_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "create_priority_level_configuration_with_http_info "
                "on FlowcontrolApiserverV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201, 202)
        resp: Response["PriorityLevelConfiguration"] = Response[
            "PriorityLevelConfiguration"
        ](result, codes_returning_objects)
        return resp

    def create(
        self,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
    ) -> "PriorityLevelConfiguration":
        r"""
            create a PriorityLevelConfiguration

            operationID: createPriorityLevelConfiguration
            path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations

            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint.
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        res = self.createPriorityLevelConfiguration(
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    @staticmethod
    def deletePriorityLevelConfiguration(
        name: str,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PriorityLevelConfiguration"]:
        r"""
        delete a PriorityLevelConfiguration

        operationID: deletePriorityLevelConfiguration
        path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}

        :param name: name for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Status    OK
          202   Status    Accepted
          401   None    Unauthorized
        """
        client_to_use = client
        inst = FlowcontrolApiserverV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "delete_priority_level_configuration_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_priority_level_configuration_with_http_info "
                "on FlowcontrolApiserverV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["dry_run"] = dry_run
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 202)
        resp: Response["PriorityLevelConfiguration"] = Response[
            "PriorityLevelConfiguration"
        ](result, codes_returning_objects)
        return resp

    def delete(
        self,
        name: Optional[str] = None,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        client: ApiClient = None,
    ) -> "PriorityLevelConfiguration":
        r"""
            delete a PriorityLevelConfiguration

            operationID: deletePriorityLevelConfiguration
            path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param grace_period_seconds: The duration in seconds before the object should
                be deleted. Value must be non-negative integer. The value zero
                indicates delete immediately. If this value is nil, the default
                grace period for the specified type will be used. Defaults to a per
                object value if not specified. zero means delete immediately.
            :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
                field will be deprecated in 1.7. Should the dependent objects be
                orphaned. If true/false, the "orphan" finalizer will be added
                to/removed from the object's finalizers list. Either this field or
                PropagationPolicy may be set, but not both.
            :param propagation_policy: Whether and how garbage collection will be
                performed. Either this field or OrphanDependents may be set, but not
                both. The default policy is decided by the existing finalizer set in
                the metadata.finalizers and the resource-specific default policy.
                Acceptable values are: 'Orphan' - orphan the dependents;
                'Background' - allow the garbage collector to delete the dependents
                in the background; 'Foreground' - a cascading policy that deletes
                all dependents in the foreground.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to delete() or in a "
                "PriorityLevelConfiguration's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.deletePriorityLevelConfiguration(
            name=effective_name,
            dry_run=dry_run,
            grace_period_seconds=grace_period_seconds,
            orphan_dependents=orphan_dependents,
            propagation_policy=propagation_policy,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    @staticmethod
    def readPriorityLevelConfiguration(
        name: str,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PriorityLevelConfiguration"]:
        r"""
        read the specified PriorityLevelConfiguration

        operationID: readPriorityLevelConfiguration
        path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}

        :param name: name for the resource
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PriorityLevelConfiguration    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = FlowcontrolApiserverV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "read_priority_level_configuration_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "read_priority_level_configuration_with_http_info "
                "on FlowcontrolApiserverV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["PriorityLevelConfiguration"] = Response[
            "PriorityLevelConfiguration"
        ](result, codes_returning_objects)
        return resp

    def read(
        self,
        name: Optional[str] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
    ) -> "PriorityLevelConfiguration":
        r"""
            read the specified PriorityLevelConfiguration

            operationID: readPriorityLevelConfiguration
            path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param pretty: If 'true', then the output is pretty printed.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to read() or in a "
                "PriorityLevelConfiguration's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.readPriorityLevelConfiguration(
            name=effective_name, pretty=pretty, client=client
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    def patchPriorityLevelConfiguration(
        self,
        name: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PriorityLevelConfiguration"]:
        r"""
        partially update the specified PriorityLevelConfiguration

        operationID: patchPriorityLevelConfiguration
        path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}

        :param name: name for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint. This field is
            required for apply requests (application/apply-patch) but optional
            for non-apply patch types (JsonPatch, MergePatch,
            StrategicMergePatch).
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param force: Force is going to "force" Apply requests. It means user will
            re-acquire conflicting fields owned by other people. Force flag must
            be unset for non-apply patch requests.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PriorityLevelConfiguration    OK
          201   PriorityLevelConfiguration    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = FlowcontrolApiserverV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "patch_priority_level_configuration_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "patch_priority_level_configuration_with_http_info "
                "on FlowcontrolApiserverV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        all_args["force"] = force
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["PriorityLevelConfiguration"] = Response[
            "PriorityLevelConfiguration"
        ](result, codes_returning_objects)
        return resp

    def update(
        self,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
    ) -> "PriorityLevelConfiguration":
        r"""
            partially update the specified PriorityLevelConfiguration

            operationID: patchPriorityLevelConfiguration
            path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}

            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint. This field is
                required for apply requests (application/apply-patch) but optional
                for non-apply patch types (JsonPatch, MergePatch,
                StrategicMergePatch).
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param force: Force is going to "force" Apply requests. It means user will
                re-acquire conflicting fields owned by other people. Force flag must
                be unset for non-apply patch requests.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        res = self.patchPriorityLevelConfiguration(
            name=self.metadata.name,
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            force=force,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    def __enter__(self):
        return self

    def __exit__(self, ex_type, ex_value, ex_traceback):
        passed = ex_type is None and ex_value is None and ex_traceback is None
        has_rollback = hasattr(self, "__rollback")
        if passed:
            try:
                self.update()
            except Exception:
                if has_rollback:
                    self.merge(getattr(self, "__rollback"), overwrite=True)
                    delattr(self, "__rollback")
                raise
        if has_rollback:
            if not passed:
                self.merge(getattr(self, "__rollback"), overwrite=True)
            delattr(self, "__rollback")
        return False

    def replacePriorityLevelConfiguration(
        self,
        name: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PriorityLevelConfiguration"]:
        r"""
        replace the specified PriorityLevelConfiguration

        operationID: replacePriorityLevelConfiguration
        path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}

        :param name: name for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PriorityLevelConfiguration    OK
          201   PriorityLevelConfiguration    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = FlowcontrolApiserverV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "replace_priority_level_configuration_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "replace_priority_level_configuration_with_http_info "
                "on FlowcontrolApiserverV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["PriorityLevelConfiguration"] = Response[
            "PriorityLevelConfiguration"
        ](result, codes_returning_objects)
        return resp

    def replacePriorityLevelConfigurationStatus(
        self,
        name: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PriorityLevelConfiguration"]:
        r"""
        replace status of the specified PriorityLevelConfiguration

        operationID: replacePriorityLevelConfigurationStatus
        path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations/{name}/status

        :param name: name for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PriorityLevelConfiguration    OK
          201   PriorityLevelConfiguration    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = FlowcontrolApiserverV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "replace_priority_level_configuration_status_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "replace_priority_level_configuration_status_with_http_info "
                "on FlowcontrolApiserverV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["PriorityLevelConfiguration"] = Response[
            "PriorityLevelConfiguration"
        ](result, codes_returning_objects)
        return resp


@dataclass
class PriorityLevelConfigurationCondition(HikaruBase):
    r"""
    PriorityLevelConfigurationCondition defines the condition of priority level.

    Full name: PriorityLevelConfigurationCondition

    Attributes:
    lastTransitionTime: `lastTransitionTime` is the last time the condition transitioned
        from one status to another.
    message: `message` is a human-readable message indicating details about last
        transition.
    reason: `reason` is a unique, one-word, CamelCase reason for the condition's last
        transition.
    status: `status` is the status of the condition. Can be True, False, Unknown.
        Required.
    type: `type` is the type of the condition. Required.
    """

    lastTransitionTime: Optional[str] = None
    message: Optional[str] = None
    reason: Optional[str] = None
    status: Optional[str] = None
    type: Optional[str] = None


@dataclass
class PriorityLevelConfigurationList(HikaruDocumentBase):
    r"""
    PriorityLevelConfigurationList is a list of PriorityLevelConfiguration objects.

    Full name: PriorityLevelConfigurationList

    Attributes:
    items: `items` is a list of request-priorities.
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata: `metadata` is the standard object's metadata. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    """

    _version = "v1beta1"
    items: List["PriorityLevelConfiguration"]
    apiVersion: Optional[str] = "flowcontrol.apiserver.k8s.io/v1beta1"
    kind: Optional[str] = "PriorityLevelConfigurationList"
    metadata: Optional["ListMeta"] = None
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def listPriorityLevelConfiguration(
        allow_watch_bookmarks: Optional[bool] = None,
        continue_: Optional[str] = None,
        field_selector: Optional[str] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        watch: Optional[bool] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PriorityLevelConfigurationList"]:
        r"""
        list or watch objects of kind PriorityLevelConfiguration

        operationID: listPriorityLevelConfiguration
        path: /apis/flowcontrol.apiserver.k8s.io/v1beta1/prioritylevelconfigurations

        :param allow_watch_bookmarks: allowWatchBookmarks requests watch events with
            type "BOOKMARK". Servers that do not implement bookmarks may ignore
            this flag and bookmarks are sent at the server's discretion. Clients
            should not assume bookmarks are returned at any specific interval,
            nor may they assume the server will send any BOOKMARK event during a
            session. If this is not a watch, this field is ignored.
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param watch: Watch for changes to the described resources and return them as a
            stream of add, update, and remove notifications. Specify
            resourceVersion.
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PriorityLevelConfigurationList    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = FlowcontrolApiserverV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "list_priority_level_configuration_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "list_priority_level_configuration_with_http_info "
                "on FlowcontrolApiserverV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["allow_watch_bookmarks"] = allow_watch_bookmarks
        all_args["_continue"] = continue_
        all_args["field_selector"] = field_selector
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["watch"] = watch
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["PriorityLevelConfigurationList"] = Response[
            "PriorityLevelConfigurationList"
        ](result, codes_returning_objects)
        return resp

    _watcher = WatcherDescriptor(
        "kubernetes.client.api",
        ".flowcontrol_apiserver_v1beta1_api",
        "FlowcontrolApiserverV1beta1Api",
        "list_priority_level_configuration",
    )


@dataclass
class PriorityLevelConfigurationReference(HikaruBase):
    r"""
    PriorityLevelConfigurationReference contains information that points to the
    "request-priority" being used.

    Full name: PriorityLevelConfigurationReference

    Attributes:
    name: `name` is the name of the priority level configuration being referenced
        Required.
    """

    name: str


@dataclass
class PriorityLevelConfigurationSpec(HikaruBase):
    r"""
    PriorityLevelConfigurationSpec specifies the configuration of a priority level.

    Full name: PriorityLevelConfigurationSpec

    Attributes:
    type: `type` indicates whether this priority level is subject to limitation on request
        execution. A value of `"Exempt"` means that requests of this priority level are
        not subject to a limit (and thus are never queued) and do not detract from the
        capacity made available to other priority levels. A value of `"Limited"` means
        that (a) requests of this priority level _are_ subject to limits and (b) some of
        the server's limited capacity is made available exclusively to this priority
        level. Required.
    limited: `limited` specifies how requests are handled for a Limited priority level.
        This field must be non-empty if and only if `type` is `"Limited"`.
    """

    type: str
    limited: Optional["LimitedPriorityLevelConfiguration"] = None


@dataclass
class PriorityLevelConfigurationStatus(HikaruBase):
    r"""
    PriorityLevelConfigurationStatus represents the current state of a "request-priority".

    Full name: PriorityLevelConfigurationStatus

    Attributes:
    conditions: `conditions` is the current state of "request-priority".
    """

    conditions: Optional[List["PriorityLevelConfigurationCondition"]] = field(
        default_factory=list
    )


@dataclass
class QueuingConfiguration(HikaruBase):
    r"""
    QueuingConfiguration holds the configuration parameters for queuing

    Full name: QueuingConfiguration

    Attributes:
    handSize: `handSize` is a small positive number that configures the shuffle sharding
        of requests into queues. When enqueuing a request at this priority level the
        request's flow identifier (a string pair) is hashed and the hash value is used to
        shuffle the list of queues and deal a hand of the size specified here. The request
        is put into one of the shortest queues in that hand. `handSize` must be no larger
        than `queues`, and should be significantly smaller (so that a few heavy flows do
        not saturate most of the queues). See the user-facing documentation for more
        extensive guidance on setting this field. This field has a default value of 8.
    queueLengthLimit: `queueLengthLimit` is the maximum number of requests allowed to be
        waiting in a given queue of this priority level at a time; excess requests are
        rejected. This value must be positive. If not specified, it will be defaulted to
        50.
    queues: `queues` is the number of queues for this priority level. The queues exist
        independently at each apiserver. The value must be positive. Setting it to 1
        effectively precludes shufflesharding and thus makes the distinguisher method of
        associated flow schemas irrelevant. This field has a default value of 64.
    """

    handSize: Optional[int] = None
    queueLengthLimit: Optional[int] = None
    queues: Optional[int] = None


@dataclass
class ResourcePolicyRule(HikaruBase):
    r"""
    ResourcePolicyRule is a predicate that matches some resource requests, testing the
    request's verb and the target resource. A ResourcePolicyRule matches a resource
    request if and only if: (a) at least one member of verbs matches the request, (b) at
    least one member of apiGroups matches the request, (c) at least one member of
    resources matches the request, and (d) either (d1) the request does not specify a
    namespace (i.e., `Namespace==""`) and clusterScope is true or (d2) the request
    specifies a namespace and least one member of namespaces matches the request's
    namespace.

    Full name: ResourcePolicyRule

    Attributes:
    apiGroups: `apiGroups` is a list of matching API groups and may not be empty. "*"
        matches all API groups and, if present, must be the only entry. Required.
    resources: `resources` is a list of matching resources (i.e., lowercase and plural)
        with, if desired, subresource. For example, [ "services", "nodes/status" ]. This
        list may not be empty. "*" matches all resources and, if present, must be the only
        entry. Required.
    verbs: `verbs` is a list of matching verbs and may not be empty. "*" matches all verbs
        and, if present, must be the only entry. Required.
    clusterScope: `clusterScope` indicates whether to match requests that do not specify a
        namespace (which happens either because the resource is not namespaced or the
        request targets all namespaces). If this field is omitted or false then the
        `namespaces` field must contain a non-empty list.
    namespaces: `namespaces` is a list of target namespaces that restricts matches. A
        request that specifies a target namespace matches only if either (a) this list
        contains that target namespace or (b) this list contains "*". Note that "*"
        matches any specified namespace but does not match a request that _does not
        specify_ a namespace (see the `clusterScope` field for that). This list may be
        empty, but only if `clusterScope` is true.
    """

    apiGroups: List[str]
    resources: List[str]
    verbs: List[str]
    clusterScope: Optional[bool] = None
    namespaces: Optional[List[str]] = field(default_factory=list)


@dataclass
class ServiceAccountSubject(HikaruBase):
    r"""
    ServiceAccountSubject holds detailed information for service-account-kind subject.

    Full name: ServiceAccountSubject

    Attributes:
    name: `name` is the name of matching ServiceAccount objects, or "*" to match
        regardless of name. Required.
    namespace: `namespace` is the namespace of matching ServiceAccount objects. Required.
    """

    name: str
    namespace: str


@dataclass
class Subject(HikaruBase):
    r"""
    Subject matches the originator of a request, as identified by the request
    authentication system. There are three ways of matching an originator; by user, group,
    or service account.

    Full name: Subject

    Attributes:
    kind: `kind` indicates which one of the other fields is non-empty. Required
    group: `group` matches based on user group name.
    serviceAccount: `serviceAccount` matches ServiceAccounts.
    user: `user` matches based on username.
    """

    kind: str
    group: Optional["GroupSubject"] = None
    serviceAccount: Optional["ServiceAccountSubject"] = None
    user: Optional["UserSubject"] = None


@dataclass
class UserSubject(HikaruBase):
    r"""
    UserSubject holds detailed information for user-kind subject.

    Full name: UserSubject

    Attributes:
    name: `name` is the username that matches, or "*" to match all usernames. Required.
    """

    name: str


@dataclass
class Overhead(HikaruBase):
    r"""
    Overhead structure represents the resource overhead associated with running a pod.

    Full name: Overhead

    Attributes:
    podFixed: PodFixed represents the fixed resource overhead associated with running a
        pod.
    """

    podFixed: Optional[Dict[str, str]] = field(default_factory=dict)


@dataclass
class RuntimeClass(HikaruDocumentBase):
    r"""
    RuntimeClass defines a class of container runtime supported in the cluster. The
    RuntimeClass is used to determine which container runtime is used to run all
    containers in a pod. RuntimeClasses are (currently) manually defined by a user or
    cluster provisioner, and referenced in the PodSpec. The Kubelet is responsible for
    resolving the RuntimeClassName reference before running the pod. For more details, see
    https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class

    Full name: RuntimeClass

    Attributes:
    handler: Handler specifies the underlying runtime and configuration that the CRI
        implementation will use to handle pods of this class. The possible values are
        specific to the node & CRI configuration. It is assumed that all handlers are
        available on every node, and handlers of the same name are equivalent on every
        node. For example, a handler called "runc" might specify that the runc OCI runtime
        (using native Linux containers) will be used to run the containers in a pod. The
        Handler must be lowercase, conform to the DNS Label (RFC 1123) requirements, and
        is immutable.
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata: More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    overhead: Overhead represents the resource overhead associated with running a pod for
        a given RuntimeClass. For more details, see
        https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md This
        field is beta-level as of Kubernetes v1.18, and is only honored by servers that
        enable the PodOverhead feature.
    scheduling: Scheduling holds the scheduling constraints to ensure that pods running
        with this RuntimeClass are scheduled to nodes that support it. If scheduling is
        nil, this RuntimeClass is assumed to be supported by all nodes.
    """

    _version = "v1beta1"
    handler: str
    apiVersion: Optional[str] = "node.k8s.io/v1beta1"
    kind: Optional[str] = "RuntimeClass"
    metadata: Optional["ObjectMeta"] = None
    overhead: Optional["Overhead"] = None
    scheduling: Optional["Scheduling"] = None
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def deleteCollectionRuntimeClass(
        continue_: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_selector: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["RuntimeClass"]:
        r"""
        delete collection of RuntimeClass

        operationID: deleteCollectionRuntimeClass
        path: /apis/node.k8s.io/v1beta1/runtimeclasses

        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Status    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = NodeV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "delete_collection_runtime_class_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_collection_runtime_class_with_http_info "
                "on NodeV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["_continue"] = continue_
        all_args["dry_run"] = dry_run
        all_args["field_selector"] = field_selector
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["RuntimeClass"] = Response["RuntimeClass"](
            result, codes_returning_objects
        )
        return resp

    def createRuntimeClass(
        self,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["RuntimeClass"]:
        r"""
        create a RuntimeClass

        operationID: createRuntimeClass
        path: /apis/node.k8s.io/v1beta1/runtimeclasses

        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   RuntimeClass    OK
          201   RuntimeClass    Created
          202   RuntimeClass    Accepted
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = NodeV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "create_runtime_class_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "create_runtime_class_with_http_info "
                "on NodeV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201, 202)
        resp: Response["RuntimeClass"] = Response["RuntimeClass"](
            result, codes_returning_objects
        )
        return resp

    def create(
        self,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
    ) -> "RuntimeClass":
        r"""
            create a RuntimeClass

            operationID: createRuntimeClass
            path: /apis/node.k8s.io/v1beta1/runtimeclasses

            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint.
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        res = self.createRuntimeClass(
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    @staticmethod
    def deleteRuntimeClass(
        name: str,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["RuntimeClass"]:
        r"""
        delete a RuntimeClass

        operationID: deleteRuntimeClass
        path: /apis/node.k8s.io/v1beta1/runtimeclasses/{name}

        :param name: name for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Status    OK
          202   Status    Accepted
          401   None    Unauthorized
        """
        client_to_use = client
        inst = NodeV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "delete_runtime_class_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_runtime_class_with_http_info "
                "on NodeV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["dry_run"] = dry_run
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 202)
        resp: Response["RuntimeClass"] = Response["RuntimeClass"](
            result, codes_returning_objects
        )
        return resp

    def delete(
        self,
        name: Optional[str] = None,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        client: ApiClient = None,
    ) -> "RuntimeClass":
        r"""
            delete a RuntimeClass

            operationID: deleteRuntimeClass
            path: /apis/node.k8s.io/v1beta1/runtimeclasses/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param grace_period_seconds: The duration in seconds before the object should
                be deleted. Value must be non-negative integer. The value zero
                indicates delete immediately. If this value is nil, the default
                grace period for the specified type will be used. Defaults to a per
                object value if not specified. zero means delete immediately.
            :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
                field will be deprecated in 1.7. Should the dependent objects be
                orphaned. If true/false, the "orphan" finalizer will be added
                to/removed from the object's finalizers list. Either this field or
                PropagationPolicy may be set, but not both.
            :param propagation_policy: Whether and how garbage collection will be
                performed. Either this field or OrphanDependents may be set, but not
                both. The default policy is decided by the existing finalizer set in
                the metadata.finalizers and the resource-specific default policy.
                Acceptable values are: 'Orphan' - orphan the dependents;
                'Background' - allow the garbage collector to delete the dependents
                in the background; 'Foreground' - a cascading policy that deletes
                all dependents in the foreground.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to delete() or in a "
                "RuntimeClass's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.deleteRuntimeClass(
            name=effective_name,
            dry_run=dry_run,
            grace_period_seconds=grace_period_seconds,
            orphan_dependents=orphan_dependents,
            propagation_policy=propagation_policy,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    @staticmethod
    def readRuntimeClass(
        name: str,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["RuntimeClass"]:
        r"""
        read the specified RuntimeClass

        operationID: readRuntimeClass
        path: /apis/node.k8s.io/v1beta1/runtimeclasses/{name}

        :param name: name for the resource
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   RuntimeClass    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = NodeV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "read_runtime_class_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "read_runtime_class_with_http_info "
                "on NodeV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["RuntimeClass"] = Response["RuntimeClass"](
            result, codes_returning_objects
        )
        return resp

    def read(
        self,
        name: Optional[str] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
    ) -> "RuntimeClass":
        r"""
            read the specified RuntimeClass

            operationID: readRuntimeClass
            path: /apis/node.k8s.io/v1beta1/runtimeclasses/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param pretty: If 'true', then the output is pretty printed.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to read() or in a "
                "RuntimeClass's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.readRuntimeClass(name=effective_name, pretty=pretty, client=client)
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    def patchRuntimeClass(
        self,
        name: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["RuntimeClass"]:
        r"""
        partially update the specified RuntimeClass

        operationID: patchRuntimeClass
        path: /apis/node.k8s.io/v1beta1/runtimeclasses/{name}

        :param name: name for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint. This field is
            required for apply requests (application/apply-patch) but optional
            for non-apply patch types (JsonPatch, MergePatch,
            StrategicMergePatch).
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param force: Force is going to "force" Apply requests. It means user will
            re-acquire conflicting fields owned by other people. Force flag must
            be unset for non-apply patch requests.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   RuntimeClass    OK
          201   RuntimeClass    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = NodeV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "patch_runtime_class_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "patch_runtime_class_with_http_info "
                "on NodeV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        all_args["force"] = force
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["RuntimeClass"] = Response["RuntimeClass"](
            result, codes_returning_objects
        )
        return resp

    def update(
        self,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
    ) -> "RuntimeClass":
        r"""
            partially update the specified RuntimeClass

            operationID: patchRuntimeClass
            path: /apis/node.k8s.io/v1beta1/runtimeclasses/{name}

            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint. This field is
                required for apply requests (application/apply-patch) but optional
                for non-apply patch types (JsonPatch, MergePatch,
                StrategicMergePatch).
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param force: Force is going to "force" Apply requests. It means user will
                re-acquire conflicting fields owned by other people. Force flag must
                be unset for non-apply patch requests.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        res = self.patchRuntimeClass(
            name=self.metadata.name,
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            force=force,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    def __enter__(self):
        return self

    def __exit__(self, ex_type, ex_value, ex_traceback):
        passed = ex_type is None and ex_value is None and ex_traceback is None
        has_rollback = hasattr(self, "__rollback")
        if passed:
            try:
                self.update()
            except Exception:
                if has_rollback:
                    self.merge(getattr(self, "__rollback"), overwrite=True)
                    delattr(self, "__rollback")
                raise
        if has_rollback:
            if not passed:
                self.merge(getattr(self, "__rollback"), overwrite=True)
            delattr(self, "__rollback")
        return False

    def replaceRuntimeClass(
        self,
        name: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["RuntimeClass"]:
        r"""
        replace the specified RuntimeClass

        operationID: replaceRuntimeClass
        path: /apis/node.k8s.io/v1beta1/runtimeclasses/{name}

        :param name: name for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   RuntimeClass    OK
          201   RuntimeClass    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = NodeV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "replace_runtime_class_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "replace_runtime_class_with_http_info "
                "on NodeV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["RuntimeClass"] = Response["RuntimeClass"](
            result, codes_returning_objects
        )
        return resp


@dataclass
class RuntimeClassList(HikaruDocumentBase):
    r"""
    RuntimeClassList is a list of RuntimeClass objects.

    Full name: RuntimeClassList

    Attributes:
    items: Items is a list of schema objects.
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata: Standard list metadata. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    """

    _version = "v1beta1"
    items: List["RuntimeClass"]
    apiVersion: Optional[str] = "node.k8s.io/v1beta1"
    kind: Optional[str] = "RuntimeClassList"
    metadata: Optional["ListMeta"] = None
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def listRuntimeClass(
        allow_watch_bookmarks: Optional[bool] = None,
        continue_: Optional[str] = None,
        field_selector: Optional[str] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        watch: Optional[bool] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["RuntimeClassList"]:
        r"""
        list or watch objects of kind RuntimeClass

        operationID: listRuntimeClass
        path: /apis/node.k8s.io/v1beta1/runtimeclasses

        :param allow_watch_bookmarks: allowWatchBookmarks requests watch events with
            type "BOOKMARK". Servers that do not implement bookmarks may ignore
            this flag and bookmarks are sent at the server's discretion. Clients
            should not assume bookmarks are returned at any specific interval,
            nor may they assume the server will send any BOOKMARK event during a
            session. If this is not a watch, this field is ignored.
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param watch: Watch for changes to the described resources and return them as a
            stream of add, update, and remove notifications. Specify
            resourceVersion.
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   RuntimeClassList    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = NodeV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "list_runtime_class_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "list_runtime_class_with_http_info "
                "on NodeV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["allow_watch_bookmarks"] = allow_watch_bookmarks
        all_args["_continue"] = continue_
        all_args["field_selector"] = field_selector
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["watch"] = watch
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["RuntimeClassList"] = Response["RuntimeClassList"](
            result, codes_returning_objects
        )
        return resp

    _watcher = WatcherDescriptor(
        "kubernetes.client.api",
        ".node_v1beta1_api",
        "NodeV1beta1Api",
        "list_runtime_class",
    )


@dataclass
class Scheduling(HikaruBase):
    r"""
    Scheduling specifies the scheduling constraints for nodes supporting a RuntimeClass.

    Full name: Scheduling

    Attributes:
    nodeSelector: nodeSelector lists labels that must be present on nodes that support
        this RuntimeClass. Pods using this RuntimeClass can only be scheduled to a node
        matched by this selector. The RuntimeClass nodeSelector is merged with a pod's
        existing nodeSelector. Any conflicts will cause the pod to be rejected in
        admission.
    tolerations: tolerations are appended (excluding duplicates) to pods running with this
        RuntimeClass during admission, effectively unioning the set of nodes tolerated by
        the pod and the RuntimeClass.
    """

    nodeSelector: Optional[Dict[str, str]] = field(default_factory=dict)
    tolerations: Optional[List["Toleration"]] = field(default_factory=list)


@dataclass
class AllowedCSIDriver(HikaruBase):
    r"""
    AllowedCSIDriver represents a single inline CSI Driver that is allowed to be used.

    Full name: AllowedCSIDriver

    Attributes:
    name: Name is the registered name of the CSI driver
    """

    name: str


@dataclass
class AllowedFlexVolume(HikaruBase):
    r"""
    AllowedFlexVolume represents a single Flexvolume that is allowed to be used.

    Full name: AllowedFlexVolume

    Attributes:
    driver: driver is the name of the Flexvolume driver.
    """

    driver: str


@dataclass
class AllowedHostPath(HikaruBase):
    r"""
    AllowedHostPath defines the host volume conditions that will be enabled by a policy
    for pods to use. It requires the path prefix to be defined.

    Full name: AllowedHostPath

    Attributes:
    pathPrefix: pathPrefix is the path prefix that the host volume must match. It does not
        support `*`. Trailing slashes are trimmed when validating the path prefix with a
        host path. Examples: `/foo` would allow `/foo`, `/foo/` and `/foo/bar` `/foo`
        would not allow `/food` or `/etc/foo`
    readOnly: when set to true, will allow host volumes matching the pathPrefix only if
        all volume mounts are readOnly.
    """

    pathPrefix: Optional[str] = None
    readOnly: Optional[bool] = None


@dataclass
class FSGroupStrategyOptions(HikaruBase):
    r"""
    FSGroupStrategyOptions defines the strategy type and options used to create the
    strategy.

    Full name: FSGroupStrategyOptions

    Attributes:
    rule: rule is the strategy that will dictate what FSGroup is used in the
        SecurityContext.
    ranges: ranges are the allowed ranges of fs groups. If you would like to force a
        single fs group then supply a single range with the same start and end. Required
        for MustRunAs.
    """

    rule: Optional[str] = None
    ranges: Optional[List["IDRange"]] = field(default_factory=list)


@dataclass
class HostPortRange(HikaruBase):
    r"""
    HostPortRange defines a range of host ports that will be enabled by a policy for pods
    to use. It requires both the start and end to be defined.

    Full name: HostPortRange

    Attributes:
    max: max is the end of the range, inclusive.
    min: min is the start of the range, inclusive.
    """

    max: int
    min: int


@dataclass
class IDRange(HikaruBase):
    r"""
    IDRange provides a min/max of an allowed range of IDs.

    Full name: IDRange

    Attributes:
    max: max is the end of the range, inclusive.
    min: min is the start of the range, inclusive.
    """

    max: int
    min: int


@dataclass
class PodDisruptionBudget(HikaruDocumentBase):
    r"""
    PodDisruptionBudget is an object to define the max disruption that can be caused to a
    collection of pods

    Full name: PodDisruptionBudget

    Attributes:
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata: Standard object's metadata. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    spec: Specification of the desired behavior of the PodDisruptionBudget.
    status: Most recently observed status of the PodDisruptionBudget.
    """

    _version = "v1beta1"
    apiVersion: Optional[str] = "policy/v1beta1"
    kind: Optional[str] = "PodDisruptionBudget"
    metadata: Optional["ObjectMeta"] = None
    spec: Optional["PodDisruptionBudgetSpec"] = None
    status: Optional["PodDisruptionBudgetStatus"] = None
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def deleteCollectionNamespacedPodDisruptionBudget(
        namespace: str,
        continue_: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_selector: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PodDisruptionBudget"]:
        r"""
        delete collection of PodDisruptionBudget

        operationID: deleteCollectionNamespacedPodDisruptionBudget
        path: /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets

        :param namespace: namespace for the resource
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Status    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = PolicyV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "delete_collection_namespaced_pod_disruption_budget_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_collection_namespaced_pod_disruption_budget_with_http_info "
                "on PolicyV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["namespace"] = namespace
        all_args["_continue"] = continue_
        all_args["dry_run"] = dry_run
        all_args["field_selector"] = field_selector
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["PodDisruptionBudget"] = Response["PodDisruptionBudget"](
            result, codes_returning_objects
        )
        return resp

    def createNamespacedPodDisruptionBudget(
        self,
        namespace: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PodDisruptionBudget"]:
        r"""
        create a PodDisruptionBudget

        operationID: createNamespacedPodDisruptionBudget
        path: /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets

        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PodDisruptionBudget    OK
          201   PodDisruptionBudget    Created
          202   PodDisruptionBudget    Accepted
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = PolicyV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "create_namespaced_pod_disruption_budget_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "create_namespaced_pod_disruption_budget_with_http_info "
                "on PolicyV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201, 202)
        resp: Response["PodDisruptionBudget"] = Response["PodDisruptionBudget"](
            result, codes_returning_objects
        )
        return resp

    def create(
        self,
        namespace: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
    ) -> "PodDisruptionBudget":
        r"""
            create a PodDisruptionBudget

            operationID: createNamespacedPodDisruptionBudget
            path: /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets

            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint.
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to create() or in a "
                "PodDisruptionBudget's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace
        res = self.createNamespacedPodDisruptionBudget(
            namespace=effective_namespace,
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    @staticmethod
    def deleteNamespacedPodDisruptionBudget(
        name: str,
        namespace: str,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PodDisruptionBudget"]:
        r"""
        delete a PodDisruptionBudget

        operationID: deleteNamespacedPodDisruptionBudget
        path: /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Status    OK
          202   Status    Accepted
          401   None    Unauthorized
        """
        client_to_use = client
        inst = PolicyV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "delete_namespaced_pod_disruption_budget_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_namespaced_pod_disruption_budget_with_http_info "
                "on PolicyV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 202)
        resp: Response["PodDisruptionBudget"] = Response["PodDisruptionBudget"](
            result, codes_returning_objects
        )
        return resp

    def delete(
        self,
        name: Optional[str] = None,
        namespace: Optional[str] = None,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        client: ApiClient = None,
    ) -> "PodDisruptionBudget":
        r"""
            delete a PodDisruptionBudget

            operationID: deleteNamespacedPodDisruptionBudget
            path: /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param grace_period_seconds: The duration in seconds before the object should
                be deleted. Value must be non-negative integer. The value zero
                indicates delete immediately. If this value is nil, the default
                grace period for the specified type will be used. Defaults to a per
                object value if not specified. zero means delete immediately.
            :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
                field will be deprecated in 1.7. Should the dependent objects be
                orphaned. If true/false, the "orphan" finalizer will be added
                to/removed from the object's finalizers list. Either this field or
                PropagationPolicy may be set, but not both.
            :param propagation_policy: Whether and how garbage collection will be
                performed. Either this field or OrphanDependents may be set, but not
                both. The default policy is decided by the existing finalizer set in
                the metadata.finalizers and the resource-specific default policy.
                Acceptable values are: 'Orphan' - orphan the dependents;
                'Background' - allow the garbage collector to delete the dependents
                in the background; 'Foreground' - a cascading policy that deletes
                all dependents in the foreground.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to delete() or in a "
                "PodDisruptionBudget's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to delete() or in a "
                "PodDisruptionBudget's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.deleteNamespacedPodDisruptionBudget(
            name=effective_name,
            namespace=effective_namespace,
            dry_run=dry_run,
            grace_period_seconds=grace_period_seconds,
            orphan_dependents=orphan_dependents,
            propagation_policy=propagation_policy,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    @staticmethod
    def readNamespacedPodDisruptionBudget(
        name: str,
        namespace: str,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PodDisruptionBudget"]:
        r"""
        read the specified PodDisruptionBudget

        operationID: readNamespacedPodDisruptionBudget
        path: /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PodDisruptionBudget    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = PolicyV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "read_namespaced_pod_disruption_budget_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "read_namespaced_pod_disruption_budget_with_http_info "
                "on PolicyV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["PodDisruptionBudget"] = Response["PodDisruptionBudget"](
            result, codes_returning_objects
        )
        return resp

    def read(
        self,
        name: Optional[str] = None,
        namespace: Optional[str] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
    ) -> "PodDisruptionBudget":
        r"""
            read the specified PodDisruptionBudget

            operationID: readNamespacedPodDisruptionBudget
            path: /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param pretty: If 'true', then the output is pretty printed.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to read() or in a "
                "PodDisruptionBudget's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to read() or in a "
                "PodDisruptionBudget's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.readNamespacedPodDisruptionBudget(
            name=effective_name,
            namespace=effective_namespace,
            pretty=pretty,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    def patchNamespacedPodDisruptionBudget(
        self,
        name: str,
        namespace: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PodDisruptionBudget"]:
        r"""
        partially update the specified PodDisruptionBudget

        operationID: patchNamespacedPodDisruptionBudget
        path: /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint. This field is
            required for apply requests (application/apply-patch) but optional
            for non-apply patch types (JsonPatch, MergePatch,
            StrategicMergePatch).
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param force: Force is going to "force" Apply requests. It means user will
            re-acquire conflicting fields owned by other people. Force flag must
            be unset for non-apply patch requests.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PodDisruptionBudget    OK
          201   PodDisruptionBudget    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = PolicyV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "patch_namespaced_pod_disruption_budget_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "patch_namespaced_pod_disruption_budget_with_http_info "
                "on PolicyV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        all_args["force"] = force
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["PodDisruptionBudget"] = Response["PodDisruptionBudget"](
            result, codes_returning_objects
        )
        return resp

    def update(
        self,
        namespace: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
    ) -> "PodDisruptionBudget":
        r"""
            partially update the specified PodDisruptionBudget

            operationID: patchNamespacedPodDisruptionBudget
            path: /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}

            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint. This field is
                required for apply requests (application/apply-patch) but optional
                for non-apply patch types (JsonPatch, MergePatch,
                StrategicMergePatch).
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param force: Force is going to "force" Apply requests. It means user will
                re-acquire conflicting fields owned by other people. Force flag must
                be unset for non-apply patch requests.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to update() or in a "
                "PodDisruptionBudget's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace
        res = self.patchNamespacedPodDisruptionBudget(
            name=self.metadata.name,
            namespace=effective_namespace,
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            force=force,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    def __enter__(self):
        return self

    def __exit__(self, ex_type, ex_value, ex_traceback):
        passed = ex_type is None and ex_value is None and ex_traceback is None
        has_rollback = hasattr(self, "__rollback")
        if passed:
            try:
                self.update()
            except Exception:
                if has_rollback:
                    self.merge(getattr(self, "__rollback"), overwrite=True)
                    delattr(self, "__rollback")
                raise
        if has_rollback:
            if not passed:
                self.merge(getattr(self, "__rollback"), overwrite=True)
            delattr(self, "__rollback")
        return False

    def replaceNamespacedPodDisruptionBudget(
        self,
        name: str,
        namespace: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PodDisruptionBudget"]:
        r"""
        replace the specified PodDisruptionBudget

        operationID: replaceNamespacedPodDisruptionBudget
        path: /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PodDisruptionBudget    OK
          201   PodDisruptionBudget    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = PolicyV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "replace_namespaced_pod_disruption_budget_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "replace_namespaced_pod_disruption_budget_with_http_info "
                "on PolicyV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["PodDisruptionBudget"] = Response["PodDisruptionBudget"](
            result, codes_returning_objects
        )
        return resp

    def replaceNamespacedPodDisruptionBudgetStatus(
        self,
        name: str,
        namespace: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PodDisruptionBudget"]:
        r"""
        replace status of the specified PodDisruptionBudget

        operationID: replaceNamespacedPodDisruptionBudgetStatus
        path: /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PodDisruptionBudget    OK
          201   PodDisruptionBudget    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = PolicyV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "replace_namespaced_pod_disruption_budget_status_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "replace_namespaced_pod_disruption_budget_status_with_http_info "
                "on PolicyV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["PodDisruptionBudget"] = Response["PodDisruptionBudget"](
            result, codes_returning_objects
        )
        return resp


@dataclass
class PodDisruptionBudgetList(HikaruDocumentBase):
    r"""
    PodDisruptionBudgetList is a collection of PodDisruptionBudgets.

    Full name: PodDisruptionBudgetList

    Attributes:
    items: items list individual PodDisruptionBudget objects
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata: Standard object's metadata. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    """

    _version = "v1beta1"
    items: List["PodDisruptionBudget"]
    apiVersion: Optional[str] = "policy/v1beta1"
    kind: Optional[str] = "PodDisruptionBudgetList"
    metadata: Optional["ListMeta"] = None
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def listNamespacedPodDisruptionBudget(
        namespace: str,
        allow_watch_bookmarks: Optional[bool] = None,
        continue_: Optional[str] = None,
        field_selector: Optional[str] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        watch: Optional[bool] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PodDisruptionBudgetList"]:
        r"""
        list or watch objects of kind PodDisruptionBudget

        operationID: listNamespacedPodDisruptionBudget
        path: /apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets

        :param namespace: namespace for the resource
        :param allow_watch_bookmarks: allowWatchBookmarks requests watch events with
            type "BOOKMARK". Servers that do not implement bookmarks may ignore
            this flag and bookmarks are sent at the server's discretion. Clients
            should not assume bookmarks are returned at any specific interval,
            nor may they assume the server will send any BOOKMARK event during a
            session. If this is not a watch, this field is ignored.
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param watch: Watch for changes to the described resources and return them as a
            stream of add, update, and remove notifications. Specify
            resourceVersion.
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PodDisruptionBudgetList    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = PolicyV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "list_namespaced_pod_disruption_budget_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "list_namespaced_pod_disruption_budget_with_http_info "
                "on PolicyV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["namespace"] = namespace
        all_args["allow_watch_bookmarks"] = allow_watch_bookmarks
        all_args["_continue"] = continue_
        all_args["field_selector"] = field_selector
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["watch"] = watch
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["PodDisruptionBudgetList"] = Response["PodDisruptionBudgetList"](
            result, codes_returning_objects
        )
        return resp

    _namespaced_watcher = WatcherDescriptor(
        "kubernetes.client.api",
        ".policy_v1beta1_api",
        "PolicyV1beta1Api",
        "list_namespaced_pod_disruption_budget",
    )

    @staticmethod
    def listPodDisruptionBudgetForAllNamespaces(
        allow_watch_bookmarks: Optional[bool] = None,
        continue_: Optional[str] = None,
        field_selector: Optional[str] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        pretty: Optional[str] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        watch: Optional[bool] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PodDisruptionBudgetList"]:
        r"""
        list or watch objects of kind PodDisruptionBudget

        operationID: listPodDisruptionBudgetForAllNamespaces
        path: /apis/policy/v1beta1/poddisruptionbudgets

        :param allow_watch_bookmarks: allowWatchBookmarks requests watch events with
            type "BOOKMARK". Servers that do not implement bookmarks may ignore
            this flag and bookmarks are sent at the server's discretion. Clients
            should not assume bookmarks are returned at any specific interval,
            nor may they assume the server will send any BOOKMARK event during a
            session. If this is not a watch, this field is ignored.
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param pretty: If 'true', then the output is pretty printed.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param watch: Watch for changes to the described resources and return them as a
            stream of add, update, and remove notifications. Specify
            resourceVersion.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PodDisruptionBudgetList    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = PolicyV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "list_pod_disruption_budget_for_all_namespaces_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "list_pod_disruption_budget_for_all_namespaces_with_http_info "
                "on PolicyV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["allow_watch_bookmarks"] = allow_watch_bookmarks
        all_args["_continue"] = continue_
        all_args["field_selector"] = field_selector
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["pretty"] = pretty
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["watch"] = watch
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["PodDisruptionBudgetList"] = Response["PodDisruptionBudgetList"](
            result, codes_returning_objects
        )
        return resp

    _watcher = WatcherDescriptor(
        "kubernetes.client.api",
        ".policy_v1beta1_api",
        "PolicyV1beta1Api",
        "list_pod_disruption_budget_for_all_namespaces",
    )


@dataclass
class PodDisruptionBudgetSpec(HikaruBase):
    r"""
    PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.

    Full name: PodDisruptionBudgetSpec

    Attributes:
    selector: Label query over pods whose evictions are managed by the disruption budget.
        A null selector selects no pods. An empty selector ({}) also selects no pods,
        which differs from standard behavior of selecting all pods. In policy/v1, an empty
        selector will select all pods in the namespace.
    maxUnavailable: An eviction is allowed if at most "maxUnavailable" pods selected by
        "selector" are unavailable after the eviction, i.e. even in absence of the evicted
        pod. For example, one can prevent all voluntary evictions by specifying 0. This is
        a mutually exclusive setting with "minAvailable".
    minAvailable: An eviction is allowed if at least "minAvailable" pods selected by
        "selector" will still be available after the eviction, i.e. even in the absence of
        the evicted pod. So for example you can prevent all voluntary evictions by
        specifying "100%".
    """

    selector: Optional["LabelSelector"] = None
    maxUnavailable: Optional[object] = field(default_factory=dict)
    minAvailable: Optional[object] = field(default_factory=dict)


@dataclass
class PodDisruptionBudgetStatus(HikaruBase):
    r"""
    PodDisruptionBudgetStatus represents information about the status of a
    PodDisruptionBudget. Status may trail the actual state of a system.

    Full name: PodDisruptionBudgetStatus

    Attributes:
    currentHealthy: current number of healthy pods
    desiredHealthy: minimum desired number of healthy pods
    disruptionsAllowed: Number of pod disruptions that are currently allowed.
    expectedPods: total number of pods counted by this disruption budget
    observedGeneration: Most recent generation observed when updating this PDB status.
        DisruptionsAllowed and other status information is valid only if
        observedGeneration equals to PDB's object generation.
    conditions: Conditions contain conditions for PDB. The disruption controller sets the
        DisruptionAllowed condition. The following are known values for the reason field
        (additional reasons could be added in the future): - SyncFailed: The controller
        encountered an error and wasn't able to compute the number of allowed disruptions.
        Therefore no disruptions are allowed and the status of the condition will be
        False. - InsufficientPods: The number of pods are either at or below the number
        required by the PodDisruptionBudget. No disruptions are allowed and the status of
        the condition will be False. - SufficientPods: There are more pods than required
        by the PodDisruptionBudget. The condition will be True, and the number of allowed
        disruptions are provided by the disruptionsAllowed property.
    disruptedPods: DisruptedPods contains information about pods whose eviction was
        processed by the API server eviction subresource handler but has not yet been
        observed by the PodDisruptionBudget controller. A pod will be in this map from the
        time when the API server processed the eviction request to the time when the pod
        is seen by PDB controller as having been marked for deletion (or after a timeout).
        The key in the map is the name of the pod and the value is the time when the API
        server processed the eviction request. If the deletion didn't occur and a pod is
        still there it will be removed from the list automatically by PodDisruptionBudget
        controller after some time. If everything goes smooth this map should be empty for
        the most of the time. Large number of entries in the map may indicate problems
        with pod deletions.
    """

    currentHealthy: int
    desiredHealthy: int
    disruptionsAllowed: int
    expectedPods: int
    observedGeneration: Optional[int] = None
    conditions: Optional[List["Condition"]] = field(default_factory=list)
    disruptedPods: Optional[Dict[str, str]] = field(default_factory=dict)


@dataclass
class PodSecurityPolicy(HikaruDocumentBase):
    r"""
    PodSecurityPolicy governs the ability to make requests that affect the Security
    Context that will be applied to a pod and container. Deprecated in 1.21.

    Full name: PodSecurityPolicy

    Attributes:
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata: Standard object's metadata. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    spec: spec defines the policy enforced.
    """

    _version = "v1beta1"
    apiVersion: Optional[str] = "policy/v1beta1"
    kind: Optional[str] = "PodSecurityPolicy"
    metadata: Optional["ObjectMeta"] = None
    spec: Optional["PodSecurityPolicySpec"] = None
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def deleteCollectionPodSecurityPolicy(
        continue_: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_selector: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PodSecurityPolicy"]:
        r"""
        delete collection of PodSecurityPolicy

        operationID: deleteCollectionPodSecurityPolicy
        path: /apis/policy/v1beta1/podsecuritypolicies

        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Status    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = PolicyV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "delete_collection_pod_security_policy_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_collection_pod_security_policy_with_http_info "
                "on PolicyV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["_continue"] = continue_
        all_args["dry_run"] = dry_run
        all_args["field_selector"] = field_selector
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["PodSecurityPolicy"] = Response["PodSecurityPolicy"](
            result, codes_returning_objects
        )
        return resp

    def createPodSecurityPolicy(
        self,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PodSecurityPolicy"]:
        r"""
        create a PodSecurityPolicy

        operationID: createPodSecurityPolicy
        path: /apis/policy/v1beta1/podsecuritypolicies

        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PodSecurityPolicy    OK
          201   PodSecurityPolicy    Created
          202   PodSecurityPolicy    Accepted
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = PolicyV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "create_pod_security_policy_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "create_pod_security_policy_with_http_info "
                "on PolicyV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201, 202)
        resp: Response["PodSecurityPolicy"] = Response["PodSecurityPolicy"](
            result, codes_returning_objects
        )
        return resp

    def create(
        self,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
    ) -> "PodSecurityPolicy":
        r"""
            create a PodSecurityPolicy

            operationID: createPodSecurityPolicy
            path: /apis/policy/v1beta1/podsecuritypolicies

            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint.
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        res = self.createPodSecurityPolicy(
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    @staticmethod
    def deletePodSecurityPolicy(
        name: str,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PodSecurityPolicy"]:
        r"""
        delete a PodSecurityPolicy

        operationID: deletePodSecurityPolicy
        path: /apis/policy/v1beta1/podsecuritypolicies/{name}

        :param name: name for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PodSecurityPolicy    OK
          202   PodSecurityPolicy    Accepted
          401   None    Unauthorized
        """
        client_to_use = client
        inst = PolicyV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "delete_pod_security_policy_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_pod_security_policy_with_http_info "
                "on PolicyV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["dry_run"] = dry_run
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 202)
        resp: Response["PodSecurityPolicy"] = Response["PodSecurityPolicy"](
            result, codes_returning_objects
        )
        return resp

    def delete(
        self,
        name: Optional[str] = None,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        client: ApiClient = None,
    ) -> "PodSecurityPolicy":
        r"""
            delete a PodSecurityPolicy

            operationID: deletePodSecurityPolicy
            path: /apis/policy/v1beta1/podsecuritypolicies/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param grace_period_seconds: The duration in seconds before the object should
                be deleted. Value must be non-negative integer. The value zero
                indicates delete immediately. If this value is nil, the default
                grace period for the specified type will be used. Defaults to a per
                object value if not specified. zero means delete immediately.
            :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
                field will be deprecated in 1.7. Should the dependent objects be
                orphaned. If true/false, the "orphan" finalizer will be added
                to/removed from the object's finalizers list. Either this field or
                PropagationPolicy may be set, but not both.
            :param propagation_policy: Whether and how garbage collection will be
                performed. Either this field or OrphanDependents may be set, but not
                both. The default policy is decided by the existing finalizer set in
                the metadata.finalizers and the resource-specific default policy.
                Acceptable values are: 'Orphan' - orphan the dependents;
                'Background' - allow the garbage collector to delete the dependents
                in the background; 'Foreground' - a cascading policy that deletes
                all dependents in the foreground.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to delete() or in a "
                "PodSecurityPolicy's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.deletePodSecurityPolicy(
            name=effective_name,
            dry_run=dry_run,
            grace_period_seconds=grace_period_seconds,
            orphan_dependents=orphan_dependents,
            propagation_policy=propagation_policy,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    @staticmethod
    def readPodSecurityPolicy(
        name: str,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PodSecurityPolicy"]:
        r"""
        read the specified PodSecurityPolicy

        operationID: readPodSecurityPolicy
        path: /apis/policy/v1beta1/podsecuritypolicies/{name}

        :param name: name for the resource
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PodSecurityPolicy    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = PolicyV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "read_pod_security_policy_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "read_pod_security_policy_with_http_info "
                "on PolicyV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["PodSecurityPolicy"] = Response["PodSecurityPolicy"](
            result, codes_returning_objects
        )
        return resp

    def read(
        self,
        name: Optional[str] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
    ) -> "PodSecurityPolicy":
        r"""
            read the specified PodSecurityPolicy

            operationID: readPodSecurityPolicy
            path: /apis/policy/v1beta1/podsecuritypolicies/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param pretty: If 'true', then the output is pretty printed.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to read() or in a "
                "PodSecurityPolicy's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.readPodSecurityPolicy(
            name=effective_name, pretty=pretty, client=client
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    def patchPodSecurityPolicy(
        self,
        name: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PodSecurityPolicy"]:
        r"""
        partially update the specified PodSecurityPolicy

        operationID: patchPodSecurityPolicy
        path: /apis/policy/v1beta1/podsecuritypolicies/{name}

        :param name: name for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint. This field is
            required for apply requests (application/apply-patch) but optional
            for non-apply patch types (JsonPatch, MergePatch,
            StrategicMergePatch).
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param force: Force is going to "force" Apply requests. It means user will
            re-acquire conflicting fields owned by other people. Force flag must
            be unset for non-apply patch requests.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PodSecurityPolicy    OK
          201   PodSecurityPolicy    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = PolicyV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "patch_pod_security_policy_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "patch_pod_security_policy_with_http_info "
                "on PolicyV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        all_args["force"] = force
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["PodSecurityPolicy"] = Response["PodSecurityPolicy"](
            result, codes_returning_objects
        )
        return resp

    def update(
        self,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
    ) -> "PodSecurityPolicy":
        r"""
            partially update the specified PodSecurityPolicy

            operationID: patchPodSecurityPolicy
            path: /apis/policy/v1beta1/podsecuritypolicies/{name}

            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint. This field is
                required for apply requests (application/apply-patch) but optional
                for non-apply patch types (JsonPatch, MergePatch,
                StrategicMergePatch).
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param force: Force is going to "force" Apply requests. It means user will
                re-acquire conflicting fields owned by other people. Force flag must
                be unset for non-apply patch requests.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        res = self.patchPodSecurityPolicy(
            name=self.metadata.name,
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            force=force,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    def __enter__(self):
        return self

    def __exit__(self, ex_type, ex_value, ex_traceback):
        passed = ex_type is None and ex_value is None and ex_traceback is None
        has_rollback = hasattr(self, "__rollback")
        if passed:
            try:
                self.update()
            except Exception:
                if has_rollback:
                    self.merge(getattr(self, "__rollback"), overwrite=True)
                    delattr(self, "__rollback")
                raise
        if has_rollback:
            if not passed:
                self.merge(getattr(self, "__rollback"), overwrite=True)
            delattr(self, "__rollback")
        return False

    def replacePodSecurityPolicy(
        self,
        name: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PodSecurityPolicy"]:
        r"""
        replace the specified PodSecurityPolicy

        operationID: replacePodSecurityPolicy
        path: /apis/policy/v1beta1/podsecuritypolicies/{name}

        :param name: name for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PodSecurityPolicy    OK
          201   PodSecurityPolicy    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = PolicyV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "replace_pod_security_policy_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "replace_pod_security_policy_with_http_info "
                "on PolicyV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["PodSecurityPolicy"] = Response["PodSecurityPolicy"](
            result, codes_returning_objects
        )
        return resp


@dataclass
class PodSecurityPolicyList(HikaruDocumentBase):
    r"""
    PodSecurityPolicyList is a list of PodSecurityPolicy objects.

    Full name: PodSecurityPolicyList

    Attributes:
    items: items is a list of schema objects.
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata: Standard list metadata. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    """

    _version = "v1beta1"
    items: List["PodSecurityPolicy"]
    apiVersion: Optional[str] = "policy/v1beta1"
    kind: Optional[str] = "PodSecurityPolicyList"
    metadata: Optional["ListMeta"] = None
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def listPodSecurityPolicy(
        allow_watch_bookmarks: Optional[bool] = None,
        continue_: Optional[str] = None,
        field_selector: Optional[str] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        watch: Optional[bool] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["PodSecurityPolicyList"]:
        r"""
        list or watch objects of kind PodSecurityPolicy

        operationID: listPodSecurityPolicy
        path: /apis/policy/v1beta1/podsecuritypolicies

        :param allow_watch_bookmarks: allowWatchBookmarks requests watch events with
            type "BOOKMARK". Servers that do not implement bookmarks may ignore
            this flag and bookmarks are sent at the server's discretion. Clients
            should not assume bookmarks are returned at any specific interval,
            nor may they assume the server will send any BOOKMARK event during a
            session. If this is not a watch, this field is ignored.
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param watch: Watch for changes to the described resources and return them as a
            stream of add, update, and remove notifications. Specify
            resourceVersion.
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   PodSecurityPolicyList    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = PolicyV1beta1Api(api_client=client_to_use)
        the_method = getattr(inst, "list_pod_security_policy_with_http_info")
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "list_pod_security_policy_with_http_info "
                "on PolicyV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["allow_watch_bookmarks"] = allow_watch_bookmarks
        all_args["_continue"] = continue_
        all_args["field_selector"] = field_selector
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["watch"] = watch
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["PodSecurityPolicyList"] = Response["PodSecurityPolicyList"](
            result, codes_returning_objects
        )
        return resp

    _watcher = WatcherDescriptor(
        "kubernetes.client.api",
        ".policy_v1beta1_api",
        "PolicyV1beta1Api",
        "list_pod_security_policy",
    )


@dataclass
class PodSecurityPolicySpec(HikaruBase):
    r"""
    PodSecurityPolicySpec defines the policy enforced.

    Full name: PodSecurityPolicySpec

    Attributes:
    fsGroup: fsGroup is the strategy that will dictate what fs group is used by the
        SecurityContext.
    runAsUser: runAsUser is the strategy that will dictate the allowable RunAsUser values
        that may be set.
    seLinux: seLinux is the strategy that will dictate the allowable labels that may be
        set.
    supplementalGroups: supplementalGroups is the strategy that will dictate what
        supplemental groups are used by the SecurityContext.
    allowPrivilegeEscalation: allowPrivilegeEscalation determines if a pod can request to
        allow privilege escalation. If unspecified, defaults to true.
    defaultAllowPrivilegeEscalation: defaultAllowPrivilegeEscalation controls the default
        setting for whether a process can gain more privileges than its parent process.
    hostIPC: hostIPC determines if the policy allows the use of HostIPC in the pod spec.
    hostNetwork: hostNetwork determines if the policy allows the use of HostNetwork in the
        pod spec.
    hostPID: hostPID determines if the policy allows the use of HostPID in the pod spec.
    privileged: privileged determines if a pod can request to be run as privileged.
    readOnlyRootFilesystem: readOnlyRootFilesystem when set to true will force containers
        to run with a read only root file system. If the container specifically requests
        to run with a non-read only root file system the PSP should deny the pod. If set
        to false the container may run with a read only root file system if it wishes but
        it will not be forced to.
    runAsGroup: RunAsGroup is the strategy that will dictate the allowable RunAsGroup
        values that may be set. If this field is omitted, the pod's RunAsGroup can take
        any value. This field requires the RunAsGroup feature gate to be enabled.
    runtimeClass: runtimeClass is the strategy that will dictate the allowable
        RuntimeClasses for a pod. If this field is omitted, the pod's runtimeClassName
        field is unrestricted. Enforcement of this field depends on the RuntimeClass
        feature gate being enabled.
    allowedCSIDrivers: AllowedCSIDrivers is an allowlist of inline CSI drivers that must
        be explicitly set to be embedded within a pod spec. An empty value indicates that
        any CSI driver can be used for inline ephemeral volumes. This is a beta field, and
        is only honored if the API server enables the CSIInlineVolume feature gate.
    allowedCapabilities: allowedCapabilities is a list of capabilities that can be
        requested to add to the container. Capabilities in this field may be added at the
        pod author's discretion. You must not list a capability in both
        allowedCapabilities and requiredDropCapabilities.
    allowedFlexVolumes: allowedFlexVolumes is an allowlist of Flexvolumes. Empty or nil
        indicates that all Flexvolumes may be used. This parameter is effective only when
        the usage of the Flexvolumes is allowed in the "volumes" field.
    allowedHostPaths: allowedHostPaths is an allowlist of host paths. Empty indicates that
        all host paths may be used.
    allowedProcMountTypes: AllowedProcMountTypes is an allowlist of allowed
        ProcMountTypes. Empty or nil indicates that only the DefaultProcMountType may be
        used. This requires the ProcMountType feature flag to be enabled.
    allowedUnsafeSysctls: allowedUnsafeSysctls is a list of explicitly allowed unsafe
        sysctls, defaults to none. Each entry is either a plain sysctl name or ends in "*"
        in which case it is considered as a prefix of allowed sysctls. Single * means all
        unsafe sysctls are allowed. Kubelet has to allowlist all allowed unsafe sysctls
        explicitly to avoid rejection. Examples: e.g. "foo/*" allows "foo/bar", "foo/baz",
        etc. e.g. "foo.*" allows "foo.bar", "foo.baz", etc.
    defaultAddCapabilities: defaultAddCapabilities is the default set of capabilities that
        will be added to the container unless the pod spec specifically drops the
        capability. You may not list a capability in both defaultAddCapabilities and
        requiredDropCapabilities. Capabilities added here are implicitly allowed, and need
        not be included in the allowedCapabilities list.
    forbiddenSysctls: forbiddenSysctls is a list of explicitly forbidden sysctls, defaults
        to none. Each entry is either a plain sysctl name or ends in "*" in which case it
        is considered as a prefix of forbidden sysctls. Single * means all sysctls are
        forbidden. Examples: e.g. "foo/*" forbids "foo/bar", "foo/baz", etc. e.g. "foo.*"
        forbids "foo.bar", "foo.baz", etc.
    hostPorts: hostPorts determines which host port ranges are allowed to be exposed.
    requiredDropCapabilities: requiredDropCapabilities are the capabilities that will be
        dropped from the container. These are required to be dropped and cannot be added.
    volumes: volumes is an allowlist of volume plugins. Empty indicates that no volumes
        may be used. To allow all volumes you may use '*'.
    """

    fsGroup: "FSGroupStrategyOptions"
    runAsUser: "RunAsUserStrategyOptions"
    seLinux: "SELinuxStrategyOptions"
    supplementalGroups: "SupplementalGroupsStrategyOptions"
    allowPrivilegeEscalation: Optional[bool] = None
    defaultAllowPrivilegeEscalation: Optional[bool] = None
    hostIPC: Optional[bool] = None
    hostNetwork: Optional[bool] = None
    hostPID: Optional[bool] = None
    privileged: Optional[bool] = None
    readOnlyRootFilesystem: Optional[bool] = None
    runAsGroup: Optional["RunAsGroupStrategyOptions"] = None
    runtimeClass: Optional["RuntimeClassStrategyOptions"] = None
    allowedCSIDrivers: Optional[List["AllowedCSIDriver"]] = field(default_factory=list)
    allowedCapabilities: Optional[List[str]] = field(default_factory=list)
    allowedFlexVolumes: Optional[List["AllowedFlexVolume"]] = field(
        default_factory=list
    )
    allowedHostPaths: Optional[List["AllowedHostPath"]] = field(default_factory=list)
    allowedProcMountTypes: Optional[List[str]] = field(default_factory=list)
    allowedUnsafeSysctls: Optional[List[str]] = field(default_factory=list)
    defaultAddCapabilities: Optional[List[str]] = field(default_factory=list)
    forbiddenSysctls: Optional[List[str]] = field(default_factory=list)
    hostPorts: Optional[List["HostPortRange"]] = field(default_factory=list)
    requiredDropCapabilities: Optional[List[str]] = field(default_factory=list)
    volumes: Optional[List[str]] = field(default_factory=list)


@dataclass
class RunAsGroupStrategyOptions(HikaruBase):
    r"""
    RunAsGroupStrategyOptions defines the strategy type and any options used to create the
    strategy.

    Full name: RunAsGroupStrategyOptions

    Attributes:
    rule: rule is the strategy that will dictate the allowable RunAsGroup values that may
        be set.
    ranges: ranges are the allowed ranges of gids that may be used. If you would like to
        force a single gid then supply a single range with the same start and end.
        Required for MustRunAs.
    """

    rule: str
    ranges: Optional[List["IDRange"]] = field(default_factory=list)


@dataclass
class RunAsUserStrategyOptions(HikaruBase):
    r"""
    RunAsUserStrategyOptions defines the strategy type and any options used to create the
    strategy.

    Full name: RunAsUserStrategyOptions

    Attributes:
    rule: rule is the strategy that will dictate the allowable RunAsUser values that may
        be set.
    ranges: ranges are the allowed ranges of uids that may be used. If you would like to
        force a single uid then supply a single range with the same start and end.
        Required for MustRunAs.
    """

    rule: str
    ranges: Optional[List["IDRange"]] = field(default_factory=list)


@dataclass
class RuntimeClassStrategyOptions(HikaruBase):
    r"""
    RuntimeClassStrategyOptions define the strategy that will dictate the allowable
    RuntimeClasses for a pod.

    Full name: RuntimeClassStrategyOptions

    Attributes:
    allowedRuntimeClassNames: allowedRuntimeClassNames is an allowlist of RuntimeClass
        names that may be specified on a pod. A value of "*" means that any RuntimeClass
        name is allowed, and must be the only item in the list. An empty list requires the
        RuntimeClassName field to be unset.
    defaultRuntimeClassName: defaultRuntimeClassName is the default RuntimeClassName to
        set on the pod. The default MUST be allowed by the allowedRuntimeClassNames list.
        A value of nil does not mutate the Pod.
    """

    allowedRuntimeClassNames: List[str]
    defaultRuntimeClassName: Optional[str] = None


@dataclass
class SELinuxStrategyOptions(HikaruBase):
    r"""
    SELinuxStrategyOptions defines the strategy type and any options used to create the
    strategy.

    Full name: SELinuxStrategyOptions

    Attributes:
    rule: rule is the strategy that will dictate the allowable labels that may be set.
    seLinuxOptions: seLinuxOptions required to run as; required for MustRunAs More info:
        https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    """

    rule: str
    seLinuxOptions: Optional["SELinuxOptions"] = None


@dataclass
class SupplementalGroupsStrategyOptions(HikaruBase):
    r"""
    SupplementalGroupsStrategyOptions defines the strategy type and options used to create
    the strategy.

    Full name: SupplementalGroupsStrategyOptions

    Attributes:
    rule: rule is the strategy that will dictate what supplemental groups is used in the
        SecurityContext.
    ranges: ranges are the allowed ranges of supplemental groups. If you would like to
        force a single supplemental group then supply a single range with the same start
        and end. Required for MustRunAs.
    """

    rule: Optional[str] = None
    ranges: Optional[List["IDRange"]] = field(default_factory=list)


@dataclass
class CSIStorageCapacity(HikaruDocumentBase):
    r"""
    CSIStorageCapacity stores the result of one CSI GetCapacity call. For a given
    StorageClass, this describes the available capacity in a particular topology segment.
    This can be used when considering where to instantiate new PersistentVolumes. For
    example this can express things like: - StorageClass "standard" has "1234 GiB"
    available in "topology.kubernetes.io/zone=us-east1" - StorageClass "localssd" has "10
    GiB" available in "kubernetes.io/hostname=knode-abc123" The following three cases all
    imply that no capacity is available for a certain combination: - no object exists with
    suitable topology and storage class name - such an object exists, but the capacity is
    unset - such an object exists, but the capacity is zero The producer of these objects
    can decide which approach is more suitable. They are consumed by the kube-scheduler if
    the CSIStorageCapacity beta feature gate is enabled there and a CSI driver opts into
    capacity-aware scheduling with CSIDriver.StorageCapacity.

    Full name: CSIStorageCapacity

    Attributes:
    storageClassName: The name of the StorageClass that the reported capacity applies to.
        It must meet the same requirements as the name of a StorageClass object
        (non-empty, DNS subdomain). If that object no longer exists, the
        CSIStorageCapacity object is obsolete and should be removed by its creator. This
        field is immutable.
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    capacity: Capacity is the value reported by the CSI driver in its GetCapacityResponse
        for a GetCapacityRequest with topology and parameters that match the previous
        fields. The semantic is currently (CSI spec 1.2) defined as: The available
        capacity, in bytes, of the storage that can be used to provision volumes. If not
        set, that information is currently unavailable and treated like zero capacity.
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    maximumVolumeSize: MaximumVolumeSize is the value reported by the CSI driver in its
        GetCapacityResponse for a GetCapacityRequest with topology and parameters that
        match the previous fields. This is defined since CSI spec 1.4.0 as the largest
        size that may be used in a CreateVolumeRequest.capacity_range.required_bytes field
        to create a volume with the same parameters as those in GetCapacityRequest. The
        corresponding value in the Kubernetes API is ResourceRequirements.Requests in a
        volume claim.
    metadata: Standard object's metadata. The name has no particular meaning. It must be
        be a DNS subdomain (dots allowed, 253 characters). To ensure that there are no
        conflicts with other CSI drivers on the cluster, the recommendation is to use
        csisc-<uuid>, a generated name, or a reverse-domain name which ends with the
        unique CSI driver name. Objects are namespaced. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    nodeTopology: NodeTopology defines which nodes have access to the storage for which
        capacity was reported. If not set, the storage is not accessible from any node in
        the cluster. If empty, the storage is accessible from all nodes. This field is
        immutable.
    """

    _version = "v1beta1"
    storageClassName: str
    apiVersion: Optional[str] = "storage.k8s.io/v1beta1"
    capacity: Optional[str] = None
    kind: Optional[str] = "CSIStorageCapacity"
    maximumVolumeSize: Optional[str] = None
    metadata: Optional["ObjectMeta"] = None
    nodeTopology: Optional["LabelSelector"] = None
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def deleteCollectionNamespacedCSIStorageCapacity(
        namespace: str,
        continue_: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_selector: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["CSIStorageCapacity"]:
        r"""
        delete collection of CSIStorageCapacity

        operationID: deleteCollectionNamespacedCSIStorageCapacity
        path: /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities

        :param namespace: namespace for the resource
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Status    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = StorageV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "delete_collection_namespaced_csi_storage_capacity_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_collection_namespaced_csi_storage_capacity_with_http_info "
                "on StorageV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["namespace"] = namespace
        all_args["_continue"] = continue_
        all_args["dry_run"] = dry_run
        all_args["field_selector"] = field_selector
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["CSIStorageCapacity"] = Response["CSIStorageCapacity"](
            result, codes_returning_objects
        )
        return resp

    def createNamespacedCSIStorageCapacity(
        self,
        namespace: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["CSIStorageCapacity"]:
        r"""
        create a CSIStorageCapacity

        operationID: createNamespacedCSIStorageCapacity
        path: /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities

        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   CSIStorageCapacity    OK
          201   CSIStorageCapacity    Created
          202   CSIStorageCapacity    Accepted
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = StorageV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "create_namespaced_csi_storage_capacity_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "create_namespaced_csi_storage_capacity_with_http_info "
                "on StorageV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201, 202)
        resp: Response["CSIStorageCapacity"] = Response["CSIStorageCapacity"](
            result, codes_returning_objects
        )
        return resp

    def create(
        self,
        namespace: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
    ) -> "CSIStorageCapacity":
        r"""
            create a CSIStorageCapacity

            operationID: createNamespacedCSIStorageCapacity
            path: /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities

            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint.
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to create() or in a "
                "CSIStorageCapacity's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace
        res = self.createNamespacedCSIStorageCapacity(
            namespace=effective_namespace,
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    @staticmethod
    def deleteNamespacedCSIStorageCapacity(
        name: str,
        namespace: str,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        body: Optional["DeleteOptions"] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["CSIStorageCapacity"]:
        r"""
        delete a CSIStorageCapacity

        operationID: deleteNamespacedCSIStorageCapacity
        path: /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param grace_period_seconds: The duration in seconds before the object should
            be deleted. Value must be non-negative integer. The value zero
            indicates delete immediately. If this value is nil, the default
            grace period for the specified type will be used. Defaults to a per
            object value if not specified. zero means delete immediately.
        :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
            field will be deprecated in 1.7. Should the dependent objects be
            orphaned. If true/false, the "orphan" finalizer will be added
            to/removed from the object's finalizers list. Either this field or
            PropagationPolicy may be set, but not both.
        :param propagation_policy: Whether and how garbage collection will be
            performed. Either this field or OrphanDependents may be set, but not
            both. The default policy is decided by the existing finalizer set in
            the metadata.finalizers and the resource-specific default policy.
            Acceptable values are: 'Orphan' - orphan the dependents;
            'Background' - allow the garbage collector to delete the dependents
            in the background; 'Foreground' - a cascading policy that deletes
            all dependents in the foreground.
        :param body:
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   Status    OK
          202   Status    Accepted
          401   None    Unauthorized
        """
        client_to_use = client
        inst = StorageV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "delete_namespaced_csi_storage_capacity_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "delete_namespaced_csi_storage_capacity_with_http_info "
                "on StorageV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["grace_period_seconds"] = grace_period_seconds
        all_args["orphan_dependents"] = orphan_dependents
        all_args["propagation_policy"] = propagation_policy
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 202)
        resp: Response["CSIStorageCapacity"] = Response["CSIStorageCapacity"](
            result, codes_returning_objects
        )
        return resp

    def delete(
        self,
        name: Optional[str] = None,
        namespace: Optional[str] = None,
        dry_run: Optional[str] = None,
        grace_period_seconds: Optional[int] = None,
        orphan_dependents: Optional[bool] = None,
        propagation_policy: Optional[str] = None,
        client: ApiClient = None,
    ) -> "CSIStorageCapacity":
        r"""
            delete a CSIStorageCapacity

            operationID: deleteNamespacedCSIStorageCapacity
            path: /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param grace_period_seconds: The duration in seconds before the object should
                be deleted. Value must be non-negative integer. The value zero
                indicates delete immediately. If this value is nil, the default
                grace period for the specified type will be used. Defaults to a per
                object value if not specified. zero means delete immediately.
            :param orphan_dependents: Deprecated: please use the PropagationPolicy, this
                field will be deprecated in 1.7. Should the dependent objects be
                orphaned. If true/false, the "orphan" finalizer will be added
                to/removed from the object's finalizers list. Either this field or
                PropagationPolicy may be set, but not both.
            :param propagation_policy: Whether and how garbage collection will be
                performed. Either this field or OrphanDependents may be set, but not
                both. The default policy is decided by the existing finalizer set in
                the metadata.finalizers and the resource-specific default policy.
                Acceptable values are: 'Orphan' - orphan the dependents;
                'Background' - allow the garbage collector to delete the dependents
                in the background; 'Foreground' - a cascading policy that deletes
                all dependents in the foreground.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to delete() or in a "
                "CSIStorageCapacity's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to delete() or in a "
                "CSIStorageCapacity's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.deleteNamespacedCSIStorageCapacity(
            name=effective_name,
            namespace=effective_namespace,
            dry_run=dry_run,
            grace_period_seconds=grace_period_seconds,
            orphan_dependents=orphan_dependents,
            propagation_policy=propagation_policy,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    @staticmethod
    def readNamespacedCSIStorageCapacity(
        name: str,
        namespace: str,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["CSIStorageCapacity"]:
        r"""
        read the specified CSIStorageCapacity

        operationID: readNamespacedCSIStorageCapacity
        path: /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   CSIStorageCapacity    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = StorageV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "read_namespaced_csi_storage_capacity_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "read_namespaced_csi_storage_capacity_with_http_info "
                "on StorageV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["CSIStorageCapacity"] = Response["CSIStorageCapacity"](
            result, codes_returning_objects
        )
        return resp

    def read(
        self,
        name: Optional[str] = None,
        namespace: Optional[str] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
    ) -> "CSIStorageCapacity":
        r"""
            read the specified CSIStorageCapacity

            operationID: readNamespacedCSIStorageCapacity
            path: /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities/{name}

            :param name: name for the resource. NOTE: if you leave out the name from the
                arguments you *must* have filled in the name attribute in the
                metadata for the resource!
            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param pretty: If 'true', then the output is pretty printed.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to read() or in a "
                "CSIStorageCapacity's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace

        if name is not None:
            effective_name = name
        elif not self.metadata or not self.metadata.name:
            raise RuntimeError(
                "There must be a name supplied in either "
                "the arguments to read() or in a "
                "CSIStorageCapacity's metadata"
            )
        else:
            effective_name = self.metadata.name
        res = self.readNamespacedCSIStorageCapacity(
            name=effective_name,
            namespace=effective_namespace,
            pretty=pretty,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        elif isinstance(res.obj, Status):
            self._status = res.obj
        return self

    def patchNamespacedCSIStorageCapacity(
        self,
        name: str,
        namespace: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["CSIStorageCapacity"]:
        r"""
        partially update the specified CSIStorageCapacity

        operationID: patchNamespacedCSIStorageCapacity
        path: /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint. This field is
            required for apply requests (application/apply-patch) but optional
            for non-apply patch types (JsonPatch, MergePatch,
            StrategicMergePatch).
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param force: Force is going to "force" Apply requests. It means user will
            re-acquire conflicting fields owned by other people. Force flag must
            be unset for non-apply patch requests.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   CSIStorageCapacity    OK
          201   CSIStorageCapacity    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = StorageV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "patch_namespaced_csi_storage_capacity_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "patch_namespaced_csi_storage_capacity_with_http_info "
                "on StorageV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        all_args["force"] = force
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["CSIStorageCapacity"] = Response["CSIStorageCapacity"](
            result, codes_returning_objects
        )
        return resp

    def update(
        self,
        namespace: Optional[str] = None,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        force: Optional[bool] = None,
        client: ApiClient = None,
    ) -> "CSIStorageCapacity":
        r"""
            partially update the specified CSIStorageCapacity

            operationID: patchNamespacedCSIStorageCapacity
            path: /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities/{name}

            :param namespace: namespace for the resource. NOTE: if you leave out the
                namespace from the arguments you *must* have filled in the namespace
                attribute in the metadata for the resource!
            :param dry_run: When present, indicates that modifications should not be
                persisted. An invalid or unrecognized dryRun directive will result
                in an error response and no further processing of the request. Valid
                values are: - All: all dry run stages will be processed
            :param field_manager: fieldManager is a name associated with the actor or
                entity that is making these changes. The value must be less than or
                128 characters long, and only contain printable characters, as
                defined by https://golang.org/pkg/unicode/#IsPrint. This field is
                required for apply requests (application/apply-patch) but optional
                for non-apply patch types (JsonPatch, MergePatch,
                StrategicMergePatch).
            :param field_validation: fieldValidation determines how the server should
                respond to unknown/duplicate fields in the object in the request.
                Introduced as alpha in 1.23, older servers or servers with the
                `ServerSideFieldValidation` feature disabled will discard valid
                values specified in this param and not perform any server side field
                validation. Valid values are: - Ignore: ignores unknown/duplicate
                fields. - Warn: responds with a warning for each unknown/duplicate
                field, but successfully serves the request. - Strict: fails the
                request on unknown/duplicate fields.
            :param force: Force is going to "force" Apply requests. It means user will
                re-acquire conflicting fields owned by other people. Force flag must
                be unset for non-apply patch requests.
            :param client: optional; instance of kubernetes.client.api_client.ApiClient
            :return: returns self; the state of self may be permuted with a returned
                HikaruDocumentBase object, whose values will be merged into self
        (if of the same type).
            :raises: KubernetesException. Raised only by the CRUD methods to signal
                that a return code of 400 or higher was returned by the underlying
                Kubernetes library.
        """

        # noinspection PyDataclass
        client = client or self.client

        if namespace is not None:
            effective_namespace = namespace
        elif not self.metadata or not self.metadata.namespace:
            raise RuntimeError(
                "There must be a namespace supplied in either "
                "the arguments to update() or in a "
                "CSIStorageCapacity's metadata"
            )
        else:
            effective_namespace = self.metadata.namespace
        res = self.patchNamespacedCSIStorageCapacity(
            name=self.metadata.name,
            namespace=effective_namespace,
            dry_run=dry_run,
            field_manager=field_manager,
            field_validation=field_validation,
            force=force,
            client=client,
        )
        if not 200 <= res.code <= 299:
            raise KubernetesException("Kubernetes returned error " + str(res.code))
        if self.__class__.__name__ == res.obj.__class__.__name__:
            self.merge(res.obj, overwrite=True)
        return self

    def __enter__(self):
        return self

    def __exit__(self, ex_type, ex_value, ex_traceback):
        passed = ex_type is None and ex_value is None and ex_traceback is None
        has_rollback = hasattr(self, "__rollback")
        if passed:
            try:
                self.update()
            except Exception:
                if has_rollback:
                    self.merge(getattr(self, "__rollback"), overwrite=True)
                    delattr(self, "__rollback")
                raise
        if has_rollback:
            if not passed:
                self.merge(getattr(self, "__rollback"), overwrite=True)
            delattr(self, "__rollback")
        return False

    def replaceNamespacedCSIStorageCapacity(
        self,
        name: str,
        namespace: str,
        dry_run: Optional[str] = None,
        field_manager: Optional[str] = None,
        field_validation: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["CSIStorageCapacity"]:
        r"""
        replace the specified CSIStorageCapacity

        operationID: replaceNamespacedCSIStorageCapacity
        path: /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities/{name}

        :param name: name for the resource
        :param namespace: namespace for the resource
        :param dry_run: When present, indicates that modifications should not be
            persisted. An invalid or unrecognized dryRun directive will result
            in an error response and no further processing of the request. Valid
            values are: - All: all dry run stages will be processed
        :param field_manager: fieldManager is a name associated with the actor or
            entity that is making these changes. The value must be less than or
            128 characters long, and only contain printable characters, as
            defined by https://golang.org/pkg/unicode/#IsPrint.
        :param field_validation: fieldValidation determines how the server should
            respond to unknown/duplicate fields in the object in the request.
            Introduced as alpha in 1.23, older servers or servers with the
            `ServerSideFieldValidation` feature disabled will discard valid
            values specified in this param and not perform any server side field
            validation. Valid values are: - Ignore: ignores unknown/duplicate
            fields. - Warn: responds with a warning for each unknown/duplicate
            field, but successfully serves the request. - Strict: fails the
            request on unknown/duplicate fields.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   CSIStorageCapacity    OK
          201   CSIStorageCapacity    Created
          401   None    Unauthorized
        """
        if client is not None:
            client_to_use = client
        else:
            # noinspection PyDataclass
            client_to_use = self.client
        inst = StorageV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "replace_namespaced_csi_storage_capacity_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "replace_namespaced_csi_storage_capacity_with_http_info "
                "on StorageV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["name"] = name
        all_args["namespace"] = namespace
        all_args["dry_run"] = dry_run
        all_args["field_manager"] = field_manager
        all_args["field_validation"] = field_validation
        body = get_clean_dict(self)
        all_args["body"] = body
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200, 201)
        resp: Response["CSIStorageCapacity"] = Response["CSIStorageCapacity"](
            result, codes_returning_objects
        )
        return resp


@dataclass
class CSIStorageCapacityList(HikaruDocumentBase):
    r"""
    CSIStorageCapacityList is a collection of CSIStorageCapacity objects.

    Full name: CSIStorageCapacityList

    Attributes:
    items: Items is the list of CSIStorageCapacity objects.
    apiVersion: APIVersion defines the versioned schema of this representation of an
        object. Servers should convert recognized schemas to the latest internal value,
        and may reject unrecognized values. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    kind: Kind is a string value representing the REST resource this object represents.
        Servers may infer this from the endpoint the client submits requests to. Cannot be
        updated. In CamelCase. More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    metadata: Standard list metadata More info:
        https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    """

    _version = "v1beta1"
    items: List["CSIStorageCapacity"]
    apiVersion: Optional[str] = "storage.k8s.io/v1beta1"
    kind: Optional[str] = "CSIStorageCapacityList"
    metadata: Optional["ListMeta"] = None
    # noinspection PyDataclass
    client: InitVar[Optional[ApiClient]] = None

    @staticmethod
    def listCSIStorageCapacityForAllNamespaces(
        allow_watch_bookmarks: Optional[bool] = None,
        continue_: Optional[str] = None,
        field_selector: Optional[str] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        pretty: Optional[str] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        watch: Optional[bool] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["CSIStorageCapacityList"]:
        r"""
        list or watch objects of kind CSIStorageCapacity

        operationID: listCSIStorageCapacityForAllNamespaces
        path: /apis/storage.k8s.io/v1beta1/csistoragecapacities

        :param allow_watch_bookmarks: allowWatchBookmarks requests watch events with
            type "BOOKMARK". Servers that do not implement bookmarks may ignore
            this flag and bookmarks are sent at the server's discretion. Clients
            should not assume bookmarks are returned at any specific interval,
            nor may they assume the server will send any BOOKMARK event during a
            session. If this is not a watch, this field is ignored.
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param pretty: If 'true', then the output is pretty printed.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param watch: Watch for changes to the described resources and return them as a
            stream of add, update, and remove notifications. Specify
            resourceVersion.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   CSIStorageCapacityList    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = StorageV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "list_csi_storage_capacity_for_all_namespaces_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "list_csi_storage_capacity_for_all_namespaces_with_http_info "
                "on StorageV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["allow_watch_bookmarks"] = allow_watch_bookmarks
        all_args["_continue"] = continue_
        all_args["field_selector"] = field_selector
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["pretty"] = pretty
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["watch"] = watch
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["CSIStorageCapacityList"] = Response["CSIStorageCapacityList"](
            result, codes_returning_objects
        )
        return resp

    _watcher = WatcherDescriptor(
        "kubernetes.client.api",
        ".storage_v1beta1_api",
        "StorageV1beta1Api",
        "list_csi_storage_capacity_for_all_namespaces",
    )

    @staticmethod
    def listNamespacedCSIStorageCapacity(
        namespace: str,
        allow_watch_bookmarks: Optional[bool] = None,
        continue_: Optional[str] = None,
        field_selector: Optional[str] = None,
        label_selector: Optional[str] = None,
        limit: Optional[int] = None,
        resource_version: Optional[str] = None,
        resource_version_match: Optional[str] = None,
        timeout_seconds: Optional[int] = None,
        watch: Optional[bool] = None,
        pretty: Optional[str] = None,
        client: ApiClient = None,
        async_req: bool = False,
    ) -> Response["CSIStorageCapacityList"]:
        r"""
        list or watch objects of kind CSIStorageCapacity

        operationID: listNamespacedCSIStorageCapacity
        path: /apis/storage.k8s.io/v1beta1/namespaces/{namespace}/csistoragecapacities

        :param namespace: namespace for the resource
        :param allow_watch_bookmarks: allowWatchBookmarks requests watch events with
            type "BOOKMARK". Servers that do not implement bookmarks may ignore
            this flag and bookmarks are sent at the server's discretion. Clients
            should not assume bookmarks are returned at any specific interval,
            nor may they assume the server will send any BOOKMARK event during a
            session. If this is not a watch, this field is ignored.
        :param continue_: The continue option should be set when retrieving more
            results from the server. Since this value is server defined, clients
            may only use the continue value from a previous query result with
            identical query parameters (except for the value of continue) and
            the server may reject a continue value it does not recognize. If the
            specified continue value is no longer valid whether due to
            expiration (generally five to fifteen minutes) or a configuration
            change on the server, the server will respond with a 410
            ResourceExpired error together with a continue token. If the client
            needs a consistent list, it must restart their list without the
            continue field. Otherwise, the client may send another list request
            with the token received with the 410 error, the server will respond
            with a list starting from the next key, but from the latest
            snapshot, which is inconsistent from the previous list results -
            objects that are created, modified, or deleted after the first list
            request will be included in the response, as long as their keys are
            after the "next key". This field is not supported when watch is
            true. Clients may start a watch from the last resourceVersion value
            returned by the server and not miss any modifications.
        :param field_selector: A selector to restrict the list of returned objects by
            their fields. Defaults to everything.
        :param label_selector: A selector to restrict the list of returned objects by
            their labels. Defaults to everything.
        :param limit: limit is a maximum number of responses to return for a list call.
            If more items exist, the server will set the `continue` field on the
            list metadata to a value that can be used with the same initial
            query to retrieve the next set of results. Setting a limit may
            return fewer than the requested amount of items (up to zero items)
            in the event all requested objects are filtered out and clients
            should only use the presence of the continue field to determine
            whether more results are available. Servers may choose not to
            support the limit argument and will return all of the available
            results. If limit is specified and the continue field is empty,
            clients may assume that no more results are available. This field is
            not supported if watch is true. The server guarantees that the
            objects returned when using continue will be identical to issuing a
            single list call without a limit - that is, no objects created,
            modified, or deleted after the first request is issued will be
            included in any subsequent continued requests. This is sometimes
            referred to as a consistent snapshot, and ensures that a client that
            is using limit to receive smaller chunks of a very large result can
            ensure they see all possible objects. If objects are updated during
            a chunked list the version of the object that was present at the
            time the first list result was calculated is returned.
        :param resource_version: resourceVersion sets a constraint on what resource
            versions a request may be served from. See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param resource_version_match: resourceVersionMatch determines how
            resourceVersion is applied to list calls. It is highly recommended
            that resourceVersionMatch be set for list calls where
            resourceVersion is set See
            https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions
            for details. Defaults to unset
        :param timeout_seconds: Timeout for the list/watch call. This limits the
            duration of the call, regardless of any activity or inactivity.
        :param watch: Watch for changes to the described resources and return them as a
            stream of add, update, and remove notifications. Specify
            resourceVersion.
        :param pretty: If 'true', then the output is pretty printed.
        :param client: optional; instance of kubernetes.client.api_client.ApiClient
        :param async_req: bool; if True, call is async and the caller must invoke
            .get() on the returned Response object. Default is False, which makes
            the call blocking.

        :return: hikaru.utils.Response[T] instance with the following codes and
            obj value types:
          Code  ObjType    Description
          -----------------------------
          200   CSIStorageCapacityList    OK
          401   None    Unauthorized
        """
        client_to_use = client
        inst = StorageV1beta1Api(api_client=client_to_use)
        the_method = getattr(
            inst, "list_namespaced_csi_storage_capacity_with_http_info"
        )
        if the_method is None:  # pragma: no cover
            raise RuntimeError(
                "Unable to locate method "
                "list_namespaced_csi_storage_capacity_with_http_info "
                "on StorageV1beta1Api; possible release mismatch?"
            )
        all_args = dict()
        all_args["namespace"] = namespace
        all_args["allow_watch_bookmarks"] = allow_watch_bookmarks
        all_args["_continue"] = continue_
        all_args["field_selector"] = field_selector
        all_args["label_selector"] = label_selector
        all_args["limit"] = limit
        all_args["resource_version"] = resource_version
        all_args["resource_version_match"] = resource_version_match
        all_args["timeout_seconds"] = timeout_seconds
        all_args["watch"] = watch
        all_args["pretty"] = pretty
        all_args["async_req"] = async_req
        result = the_method(**all_args)
        codes_returning_objects = (200,)
        resp: Response["CSIStorageCapacityList"] = Response["CSIStorageCapacityList"](
            result, codes_returning_objects
        )
        return resp

    _namespaced_watcher = WatcherDescriptor(
        "kubernetes.client.api",
        ".storage_v1beta1_api",
        "StorageV1beta1Api",
        "list_namespaced_csi_storage_capacity",
    )


CronJob._watcher_cls = CronJobList
EndpointSlice._watcher_cls = EndpointSliceList
Event._watcher_cls = EventList
FlowSchema._watcher_cls = FlowSchemaList
PriorityLevelConfiguration._watcher_cls = PriorityLevelConfigurationList
RuntimeClass._watcher_cls = RuntimeClassList
PodDisruptionBudget._watcher_cls = PodDisruptionBudgetList
PodSecurityPolicy._watcher_cls = PodSecurityPolicyList
CSIStorageCapacity._watcher_cls = CSIStorageCapacityList


globs = dict(globals())
__all__ = [c.__name__ for c in globs.values()
           if type(c) == type]
del globs
